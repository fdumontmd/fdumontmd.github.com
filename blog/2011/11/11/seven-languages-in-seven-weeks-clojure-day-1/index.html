
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Seven Languages in Seven Weeks Clojure Day 1 - Wakatta!</title>
  <meta name="author" content="Frédéric Dumont">

  
  <meta name="description" content="Sixth week, sixth language, this time Clojure, the latest attempt to make Lisp popular. Clojure has the usual features of Lisp: code as data, macros &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.wakatta.jp/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Wakatta!" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-26245052-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wakatta!</a></h1>
  
    <h2>Like Eureka!, only cooler</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.wakatta.jp" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Seven Languages in Seven Weeks Clojure Day 1</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-11T08:02:00+09:00" pubdate data-updated="true">Nov 11<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Sixth week, sixth language, this time <a href="http://clojure.org/">Clojure</a>, the latest attempt to make <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> popular.</p>

<!--more-->


<p>Clojure has the usual features of Lisp: code as data, macros, lists among many other containers (no, Lisp is not just lists), and so on. It also brings other features, such as pattern matching, and treating some containers as functions for specific purposes (both features that <a href="http://arclanguage.org/">Arc</a>, the language that <a href="http://www.paulgraham.com/">Paul Graham</a> invented, seems also to have). Pattern matching is certainly a welcome feature; I have to see more Clojure code to figure out whether I like the data as function one (I&#8217;m sure it allows very neat idioms).</p>

<p>Clojure is also supports a kind of lazy evaluation, but simpler than Haskell&#8217;s.</p>

<p>Finally, Clojure runs on both the JVM and the CLR, which allows it to go wherever either platform goes (which means pretty much everywhere), and to reuse these platforms&#8217; extensive libraries.</p>

<p>The first day covers little, compared to other languages. Various containers are introduced, along with some useful functions operating on them; pattern matching is described (it is similar to Erlang&#8217;s and other functional languages); finally we learn how to define functions, and use them in higher-order functions like <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/apply"><code>apply</code></a>.</p>

<h2>Exercises</h2>

<p>Comparatively to previous languages&#8217; first day, today is very short and simple.</p>

<h3>Define function big</h3>

<p>Nothing special here, the function <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/count"><code>count</code></a> works on all collections, including strings.</p>

<figure class='code'><figcaption><span>Define function big  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">defn </span><span class="nv">big</span>
</span><span class='line'>             <span class="s">&quot;Is string st longer than n characters?&quot;</span>
</span><span class='line'>             <span class="p">[</span><span class="nv">st</span> <span class="nv">n</span><span class="p">]</span>
</span><span class='line'>             <span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nb">count </span><span class="nv">st</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
</span><span class='line'><span class="o">#</span><span class="ss">&#39;user/big</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><figcaption><span>Test function big  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">big</span> <span class="s">&quot;hello&quot;</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="nv">false</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">big</span> <span class="s">&quot;hello&quot;</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="nv">true</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Define function collection-type</h3>

<p>Using only functions and concepts seen so far, a first implementation using map. First I use the repl to get the class of these containers:</p>

<figure class='code'><figcaption><span>class of containers  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="p">())</span>
</span><span class='line'><span class="nv">clojure</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">PersistentList$EmptyList</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="nv">clojure</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">PersistentList</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="p">[])</span>
</span><span class='line'><span class="nv">clojure</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">PersistentVector</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="p">{})</span>
</span><span class='line'><span class="nv">clojure</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">PersistentArrayMap</span>
</span></code></pre></td></tr></table></div></figure>


<p>So the empty list has a different class from a non-empty list.</p>

<p>Now I can map these classes to the proper symbol:</p>

<figure class='code'><figcaption><span>mapping classes to symbols  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">col-classes</span> <span class="p">{(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="nv">:list,</span> <span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">())</span> <span class="nv">:list,</span> <span class="p">(</span><span class="nb">class </span><span class="p">[])</span> <span class="nv">:vector,</span> <span class="p">(</span><span class="nb">class </span><span class="p">{})</span> <span class="nv">:map</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>With this, getting the right answer is as simple as:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">col-classes</span> <span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">()))</span>
</span><span class='line'><span class="nv">:list</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">col-classes</span> <span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
</span><span class='line'><span class="nv">:list</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">col-classes</span> <span class="p">(</span><span class="nb">class </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]))</span>
</span><span class='line'><span class="nv">:vector</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">col-classes</span> <span class="p">(</span><span class="nb">class </span><span class="p">{</span><span class="nv">:one</span> <span class="s">&quot;one&quot;</span><span class="p">}))</span>
</span><span class='line'><span class="nv">:map</span>
</span></code></pre></td></tr></table></div></figure>


<p>So the function can be written as:</p>

<figure class='code'><figcaption><span>Define function collection-type  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">defn </span><span class="nv">collection-type</span>
</span><span class='line'>             <span class="s">&quot;Return either :list, :vector or :map, depending of the type of col.&quot;</span>
</span><span class='line'>             <span class="p">[</span><span class="nv">col</span><span class="p">]</span>
</span><span class='line'>             <span class="p">({(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="nv">:list,</span> <span class="p">(</span><span class="nb">class </span><span class="o">&#39;</span><span class="p">())</span> <span class="nv">:list,</span> <span class="p">(</span><span class="nb">class </span><span class="p">[])</span> <span class="nv">:vector,</span> <span class="p">(</span><span class="nb">class </span><span class="p">{})</span> <span class="nv">:map</span><span class="p">}</span> <span class="p">(</span><span class="nb">class </span><span class="nv">col</span><span class="p">)))</span>
</span><span class='line'><span class="o">#</span><span class="ss">&#39;user/collection-type</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing it on literal values:</p>

<figure class='code'><figcaption><span>Test function collection-type  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="p">())</span>
</span><span class='line'><span class="nv">:list</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class='line'><span class="nv">:list</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class='line'><span class="nv">:list</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
</span><span class='line'><span class="nv">:vector</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="p">{</span><span class="nv">:one</span> <span class="s">&quot;one&quot;</span><span class="p">})</span>
</span><span class='line'><span class="nv">:map</span>
</span></code></pre></td></tr></table></div></figure>


<p>Interesting, perhaps, but there must be a better way. Using type predicates (<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/list?"><code>list?</code></a>, <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/map?"><code>map?</code></a> and <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/vector?"><code>vector?</code></a>), and the already seen <a href="http://clojure.org/special_forms#Special%20Forms--(if%20test%20then%20else?"><code>if</code></a>):</p>

<figure class='code'><figcaption><span>collection-type, predicate edition  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="n">user</span><span class="o">=&gt;</span> <span class="p">(</span><span class="n">defn</span> <span class="n">collection</span><span class="o">-</span><span class="n">type</span>
</span><span class='line'>             <span class="s">&quot;Return either :list, :vector or :map, depending of the type of col.&quot;</span>
</span><span class='line'>             <span class="p">[</span><span class="n">col</span><span class="p">]</span>
</span><span class='line'>             <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">list</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">map</span>
</span><span class='line'>                     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">vector</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">vector</span><span class="p">))))</span>
</span><span class='line'><span class="err">#&#39;</span><span class="n">user</span><span class="o">/</span><span class="n">collection</span><span class="o">-</span><span class="n">type</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing output is not repeated, as it is identical to the one above.</p>

<p>These nested <code>if</code>&#8217;s are ugly. Fortunately, Lisp has a kind of generalized <code>switch</code>, called <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/cond"><code>cond</code></a>. So the definition above is equivalent to</p>

<figure class='code'><figcaption><span>collection-type, cond predicate edition  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="n">user</span><span class="o">=&gt;</span> <span class="p">(</span><span class="n">defn</span> <span class="n">collection</span><span class="o">-</span><span class="n">type</span>
</span><span class='line'>             <span class="s">&quot;Return either :list, :vector or :map, depending of the type of col.&quot;</span>
</span><span class='line'>             <span class="p">[</span><span class="n">col</span><span class="p">]</span>
</span><span class='line'>             <span class="p">(</span><span class="k">cond</span> <span class="p">(</span><span class="n">list</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">list</span>
</span><span class='line'>                   <span class="p">(</span><span class="n">map</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">map</span>
</span><span class='line'>                   <span class="p">(</span><span class="n">vector</span><span class="err">?</span> <span class="n">col</span><span class="p">)</span> <span class="p">:</span><span class="n">vector</span><span class="p">))</span>
</span><span class='line'><span class="err">#&#39;</span><span class="n">user</span><span class="o">/</span><span class="n">collection</span><span class="o">-</span><span class="n">type</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now this is clean and elegant.</p>

<p>Once again, the test returns the expected results so they are not reproduced.</p>

<p>One thing to note: the <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/cons"><code>cons</code></a> function does not return a list, but a sequence (this is unlike <code>cons</code> in all the other Lisps):</p>

<figure class='code'><figcaption><span>cons is not a team player  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
</span><span class='line'><span class="nv">clojure</span><span class="o">.</span><span class="nv">lang</span><span class="o">.</span><span class="nv">Cons</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">list?</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
</span><span class='line'><span class="nv">false</span>
</span><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq? </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
</span><span class='line'><span class="nv">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fortunately, <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/assoc"><code>assoc</code></a> is better behaved:</p>

<figure class='code'><figcaption><span>assoc  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">collection-type</span> <span class="p">(</span><span class="nb">assoc </span> <span class="p">{</span><span class="nv">:two</span> <span class="mi">2</span><span class="p">}</span> <span class="nv">:one</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="nv">:map</span>
</span></code></pre></td></tr></table></div></figure>


<p>I like the idea of a collection&#8217;s type not changing when I add element, so the behaviour of <code>cons</code> is something I will have to watch for (or find the better way that must exist).</p>

<p>And this is all for Day 1.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Frédéric Dumont</span></span>

      








  


<time datetime="2011-11-11T08:02:00+09:00" pubdate data-updated="true">Nov 11<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/books/'>Books</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.wakatta.jp/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/" data-via="" data-counturl="http://blog.wakatta.jp/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/11/09/haskell-foldl-as-foldr/" title="Previous Post: Haskell: foldl as foldr">&laquo; Haskell: foldl as foldr</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/11/11/haskell-foldr-as-foldl/" title="next Post: Haskell: foldr as foldl">Haskell: foldr as foldl &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>About Wakatta!</h1>
  <p>
		<a href="/about">more...</a>
	</p>
</section>

<section>
	<h1>Seven Languages in Seven Weeks Series</h1>
	
		<ul>
		
			<li class="post"><a href="/blog/2011/10/11/seven-languages-in-seven-weeks/">Intro</a></li>
		
			<li class="post"><a href="/blog/2011/10/11/seven-languages-in-seven-weeks-ruby-day-1/">Ruby Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/12/seven-languages-in-seven-weeks-ruby-day-2/">Ruby Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/13/seven-languages-in-seven-weeks-ruby-day-3/">Ruby Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/18/seven-languages-in-seven-weeks-io-day-1/">Io Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/19/seven-languages-in-seven-weeks-io-day-2/">Io Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/20/seven-languages-in-seven-weeks-io-day-3/">Io Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/21/seven-languages-in-seven-weeks-about-io/">About Io</a></li>
		
			<li class="post"><a href="/blog/2011/10/23/seven-languages-in-seven-weeks-prolog-day-1/">Prolog Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/23/seven-languages-in-seven-weeks-prolog-day-2/">Prolog Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/24/seven-languages-in-seven-weeks-prolog-day-3/">Prolog Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/28/seven-languages-in-seven-weeks-scala-day-1/">Scala Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/29/seven-languages-in-seven-weeks-scala-day-2/">Scala Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/30/seven-languages-in-seven-weeks-scala-day-3/">Scala Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/11/04/seven-languages-in-seven-weeks-erlang-day-1/">Erlang Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/05/seven-languages-in-seven-weeks-erlang-day-2/">Erlang Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/06/seven-languages-in-seven-weeks-erlang-day-3/">Erlang Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/">Clojure Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/12/seven-languages-in-seven-weeks-clojure-day-2/">Clojure Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1/">Haskell Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/">Haskell Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3/">Haskell Day 3</a></li>
		
		</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3/">Seven Languages in Seven Weeks Haskell Day 3</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/">Seven Languages in Seven Weeks Haskell Day 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1/">Seven Languages in Seven Weeks Haskell Day 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/13/seven-languages-in-seven-weeks-clojure-day-3/">Seven Languages in Seven Weeks Clojure Day 3</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/12/seven-languages-in-seven-weeks-clojure-day-2/">Seven Languages in Seven Weeks Clojure Day 2</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/fdumontmd">@fdumontmd</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'fdumontmd',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Frédéric Dumont -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'wakatta-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.wakatta.jp/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/';
        var disqus_url = 'http://blog.wakatta.jp/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
