
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Seven Languages in Seven Weeks Haskell Day 2 - Wakatta!</title>
  <meta name="author" content="Frédéric Dumont">

  
  <meta name="description" content="Today introduces the functional aspects of Haskell: higher order functions, partial application of functions and lazy evaluation. Higher order &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Wakatta!" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">



  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-26245052-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wakatta!</a></h1>
  
    <h2>Like Eureka!, only cooler</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.wakatta.jp" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Seven Languages in Seven Weeks Haskell Day 2</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-18T09:39:00+09:00" pubdate data-updated="true">Nov 18<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Today introduces the functional aspects of Haskell: higher order functions, partial application of functions and lazy evaluation.</p>

<!--more-->


<p>Higher order functions should no longer be surprising: many languages have that, even if Haskell other features make them very easy to use.</p>

<p>Partial application is such a feature. A function can be passed some, but not all its arguments, meaning that it is still a function, not a value. It reduces the number of anonymous functions one needs to write when using higher order functions.</p>

<p>Lazy evaluation is something very unique (among the lazy languages, only Haskell is somewhat mainstream). Clojure has lazy lists, which is cool, but lazy evaluation applies to everything. A piece of data can refer to itself in its definition, as long as the part that is needed can be evaluated before the part it depends on.</p>

<p>For instance, a canonical definition of the Fibonacci sequence is</p>

<figure class='code'><figcaption><span>Fibonacci sequence  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>fibs</code> list is the list of Fibonacci numbers. It starts with 1, 1, then the list of itself summed with its own tail&#8230; but the 3rd number depends on the first and the second, so its ok. By the time we need to compute the 4th, the 3rd is already known, and so on.</p>

<p>It takes but an instant to compute the 100000th number in the sequence:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Parse&gt; fibs !! 100000
</span><span class='line'>42026927029951543863190051012939151317739157026322345033047..... -- number truncated to save space</span></code></pre></td></tr></table></div></figure>


<p>Which brings me to a remark on the book: why on earth is <code>fibNth</code> defined the way it is? That function exists, and is called <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:-33--33-"><code>!!</code></a>. The code in the book is convoluted, does not need that many parenthesis, and even if you have a problem with <code>!!</code>, there is no need to use both <code>take</code> and <code>drop</code> if you&#8217;re going to take the <code>head</code> of the result (<code>take</code> will make a copy of the list for no good reason).</p>

<h2>Exercises</h2>

<p>In general I tried to avoid standard functions that implement a significant portion of the intended behaviour. So I didn&#8217;t use <code>sort</code> in my sort function, or <code>read</code> in parsing, &#8230;</p>

<h3>Simple sort</h3>

<p>A good sort algorithm is always tricky, but insertion sort is simple enough and easy to express with pattern matching. My implementation has the same signature as the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-List.html#v:sort"><code>sort</code></a> function. It expects is arguments to have the class <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#t:Ord"><code>Ord</code></a>s, which guarantees they can be compared.</p>

<figure class='code'><figcaption><span> (mysort.hs)</span> <a href='/downloads/code/7l7w/haskell/mysort.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">MySort</span> <span class="kr">where</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Ord</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_sort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">my_sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_insert</span> <span class="n">x</span> <span class="o">$</span> <span class="n">my_sort</span> <span class="n">xs</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">my_insert</span> <span class="n">x</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span><span class='line'>        <span class="n">my_insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>        <span class="ow">=</span> <span class="n">y</span><span class="kt">:</span><span class="n">my_insert</span> <span class="n">x</span> <span class="n">ys</span>
</span><span class='line'>                           <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing it:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*MySort&gt; my_sort ([1..10] ++ [10, 9.. 1])
</span><span class='line'>[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]</span></code></pre></td></tr></table></div></figure>


<h3>Sort using comparison function</h3>

<p>Sort using a specific comparison function is not harder. The standard implementation uses <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#t:Ordering"><code>Data.Ord.Ordering</code></a> to replace <code>&gt;</code> by the comparison result <code>GT</code>. My implementation has the same signature as the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-List.html#v:sortBy"><code>sortBy</code></a>, but still uses the insertion sort as in <code>my_sort</code>.</p>

<figure class='code'><figcaption><span> (mysortby.hs)</span> <a href='/downloads/code/7l7w/haskell/mysortby.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">MySort</span> <span class="kr">where</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Ord</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="kr">_</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="o">$</span> <span class="n">my_sort_by</span> <span class="n">f</span> <span class="n">xs</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">my_insert_by</span> <span class="kr">_</span> <span class="n">x</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span><span class='line'>        <span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">==</span> <span class="kt">GT</span> <span class="ow">=</span> <span class="n">y</span><span class="kt">:</span><span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="n">ys</span>
</span><span class='line'>                                <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing it (using <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#v:compare"><code>compare</code></a> on the absolute value):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*MySort&gt; my_sort_by (\a b -&gt; compare (abs a) (abs b)) ([10, 9..1] ++ [-10..(-1)])
</span><span class='line'>[1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10]</span></code></pre></td></tr></table></div></figure>


<h3>Parse string into number</h3>

<p>Parsing is not hard; to do it I break the string into a integral part, and the fractional part. Both are then cleaned to remove non digits.</p>

<p>The integral part is parsed left to right (with <code>foldl</code>), each time multiplying the already parsed number by 10 before adding the current number.</p>

<p>The fractional part is parsed right to left (with <code>foldr</code>), dividing the already parsed number by 10 before adding the current number.</p>

<p>Note the use of <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:fromIntegral"><code>fromIntegral</code></a> function. This is used to convert and integral number (<code>Int</code>, <code>Integer</code>, &#8230;) into any type of number. This is necessary to be allowed to divide the results and add the fractional part.</p>

<p>The use of fractional arithmetic makes this function less effective than <code>read</code>.</p>

<figure class='code'><figcaption><span> (parse.hs)</span> <a href='/downloads/code/7l7w/haskell/parse.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Parse</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Char</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.List</span>
</span><span class='line'>
</span><span class='line'><span class="nf">parse</span> <span class="n">str</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">frac</span><span class="p">)</span> <span class="ow">=</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="n">str</span>
</span><span class='line'>    <span class="kr">in</span> <span class="n">foldl&#39;</span> <span class="n">pDig</span> <span class="mi">0</span> <span class="p">(</span><span class="n">clean</span> <span class="n">dig</span><span class="p">)</span> <span class="o">+</span> <span class="n">foldr</span> <span class="n">pFrac</span> <span class="mi">0</span> <span class="p">(</span><span class="n">clean</span> <span class="n">frac</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean</span> <span class="n">s</span>   <span class="ow">=</span> <span class="n">filter</span> <span class="n">isDigit</span> <span class="n">s</span>
</span><span class='line'><span class="nf">pDig</span>  <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">toNum</span> <span class="n">b</span>
</span><span class='line'><span class="nf">pFrac</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">toNum</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">/</span><span class="mi">10</span>
</span><span class='line'><span class="nf">toNum</span> <span class="n">c</span>   <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">ord</span> <span class="n">c</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">&#39;0&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Parse&gt; parse "$2,345,678.99"
</span><span class='line'>2345678.99
</span><span class='line'>*Parse&gt; parse "2,345"
</span><span class='line'>2345.0
</span><span class='line'>*Parse&gt; parse ".99"
</span><span class='line'>0.99
</span><span class='line'>*Parse&gt; parse ".234"
</span><span class='line'>0.23399999999999999</span></code></pre></td></tr></table></div></figure>


<h3>Lazy sequences</h3>

<p>Once again, nothing difficult. Haskell notation pretty much reads as a specification of the problem:</p>

<figure class='code'><figcaption><span> (lazy.hs)</span> <a href='/downloads/code/7l7w/haskell/lazy.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Lazy</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">thirds</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">..</span><span class="p">]</span>
</span><span class='line'><span class="nf">fifths</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">5</span><span class="o">..</span><span class="p">]</span>
</span><span class='line'><span class="nf">eighths</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">thirds</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fifths</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Lazy&gt; take 10 $ thirds 10
</span><span class='line'>[10,13,16,19,22,25,28,31,34,37]
</span><span class='line'>*Lazy&gt; take 10 $ fifths 20
</span><span class='line'>[20,25,30,35,40,45,50,55,60,65]
</span><span class='line'>*Lazy&gt; take 10 $ eighths 10 20
</span><span class='line'>[30,38,46,54,62,70,78,86,94,102]</span></code></pre></td></tr></table></div></figure>


<h3>Partial application</h3>

<p>Notice the use of partial application of operators: if you wrap the operator and its argument in parenthesis (they are needed here), you have a function that takes the missing argument. The missing argument can be the left one as see here.</p>

<figure class='code'><figcaption><span> (partial.hs)</span> <a href='/downloads/code/7l7w/haskell/partial.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Partial</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">half</span> <span class="ow">=</span> <span class="p">(</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">terminate</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Partial&gt; half 10
</span><span class='line'>5.0
</span><span class='line'>*Partial&gt; terminate "Hello"
</span><span class='line'>"Hello\n"</span></code></pre></td></tr></table></div></figure>


<h2>Challenges</h2>

<h3>Greatest Common Denominator</h3>

<p>I must have missed something, because that was hardly a challenge. I just implemented the <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>:</p>

<figure class='code'><figcaption><span> (gcd.hs)</span> <a href='/downloads/code/7l7w/haskell/gcd.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">GCD</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- Euclidean algorithm</span>
</span><span class='line'><span class="nf">my_gcd</span> <span class="n">m</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span>     <span class="ow">=</span> <span class="n">my_gcd</span> <span class="n">n</span> <span class="n">m</span>
</span><span class='line'>           <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>    <span class="ow">=</span> <span class="n">m</span>
</span><span class='line'>           <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">my_gcd</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*GCD&gt; my_gcd 1961 901
</span><span class='line'>53
</span><span class='line'>*GCD&gt; my_gcd 901 1961 
</span><span class='line'>53
</span><span class='line'>*GCD&gt; gcd 1961 901
</span><span class='line'>53</span></code></pre></td></tr></table></div></figure>


<p><code>my_gcd</code> agrees with the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:gcd"><code>gcd</code></a> function.</p>

<h3>Lazy prime number sequences</h3>

<p>This one was a bit trickier, yet an implementation that closely follows the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> algorithm is fairly short.</p>

<p>I first need a difference function that works on infinite lists: I manage this by taking into account the fact that the lists are always sorted. The <code>minus</code> just compares the first item of its arguments, so it can work linearly on both of them. Note that this function is not able to work on finite lists, but in this context there is no need to.</p>

<p>The implementation follows the proposed optimizations: it puts 2 in the prime number list right from the start, and skips other even numbers. It also start filtering at <code>p*p</code>, as smaller multiples have been filtered already (being a multiple of smaller prime numbers).</p>

<figure class='code'><figcaption><span> (sieve.hs)</span> <a href='/downloads/code/7l7w/haskell/sieve.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Sieve</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">minus</span> <span class="n">xl</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">yl</span><span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">minus</span> <span class="n">xs</span> <span class="n">ys</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">minus</span> <span class="n">xs</span> <span class="n">yl</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">minus</span> <span class="n">xl</span> <span class="n">ys</span>
</span><span class='line'>
</span><span class='line'><span class="nf">primes</span> <span class="ow">=</span> <span class="mi">2</span><span class="kt">:</span><span class="n">sieve</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span> <span class="o">..</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">sieve</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">p</span><span class="kt">:</span><span class="n">sieve</span> <span class="p">(</span><span class="n">xs</span> <span class="p">`</span><span class="n">minus</span><span class="p">`</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">p</span> <span class="o">..</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>The implementation is very slow, but can compute the first 1000 prime numbers.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Sieve&gt; primes !! 1000
</span><span class='line'>7927</span></code></pre></td></tr></table></div></figure>


<p>This turns out to be the first implementation on the Prime Number generator <a href="http://www.haskell.org/haskellwiki/Prime_numbers">page</a> on the Haskell wiki. Other implementations are much smarter and faster.</p>

<h3>Breaking string into lines</h3>

<p>The exercise description seems to be missing something: a line length. So I have added that to the functions.</p>

<p>Breaking into words is best done with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:words"><code>words</code></a>, but I implemented my version. I actually started with a first abstraction, not really necessary here, that splits a sequence based on a predicate (items that return true for the predicate are all removed). Then <code>my_words</code> is just calling that function with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Char.html#v:isSpace"><code>isSpace</code></a> as the predicate.</p>

<p>To combine words back into lines, I used two small functions: one (<code>accumUntil</code>) builds a line one word at a time, and stops when the line is too long. It starts with a word as the first tentative line, to make sure that a line is not empty even if a word is too long to fit.</p>

<p>The other function (<code>loop</code>) uses the previous one to build a list of lines until the list of words is empty.</p>

<figure class='code'><figcaption><span> (split.hs)</span> <a href='/downloads/code/7l7w/haskell/split.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Split</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Char</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- generalize words and lines: remove extra break characters at the start,</span>
</span><span class='line'><span class="c1">-- then split at the next break characters; recurse on the rest</span>
</span><span class='line'>
</span><span class='line'><span class="nf">breakAtEvery</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">dropWhile</span> <span class="n">f</span> <span class="n">xs</span> <span class="kr">of</span>
</span><span class='line'>                      <span class="kt">[]</span>  <span class="ow">-&gt;</span> <span class="kt">[]</span>
</span><span class='line'>                      <span class="n">xs&#39;</span> <span class="ow">-&gt;</span> <span class="n">p</span><span class="kt">:</span><span class="n">breakAtEvery</span> <span class="n">f</span> <span class="n">r</span>
</span><span class='line'>                        <span class="kr">where</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">break</span> <span class="n">f</span> <span class="n">xs&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_words</span> <span class="ow">=</span> <span class="n">breakAtEvery</span> <span class="n">isSpace</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- loop iterate over lines built by accumUntil</span>
</span><span class='line'><span class="c1">-- accumUntil builds a line (at least one word) and adds words</span>
</span><span class='line'><span class="c1">-- until the length is too long</span>
</span><span class='line'>
</span><span class='line'><span class="nf">split</span> <span class="n">m</span> <span class="n">str</span> <span class="ow">=</span> <span class="n">loop</span> <span class="o">$</span> <span class="n">my_words</span> <span class="n">str</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">loop</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'>        <span class="n">loop</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">w</span> <span class="n">words</span> <span class="kr">of</span>
</span><span class='line'>                           <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
</span><span class='line'>                           <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">line</span><span class="kt">:</span><span class="n">loop</span> <span class="n">rest</span>
</span><span class='line'>        <span class="n">accumUntil</span> <span class="kr">_</span> <span class="n">line</span> <span class="kt">[]</span>        <span class="ow">=</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class='line'>        <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">line</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">line&#39;</span> <span class="ow">=</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">w</span>
</span><span class='line'>                                      <span class="kr">in</span> <span class="kr">if</span> <span class="p">(</span><span class="n">length</span> <span class="n">line&#39;</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'>                                         <span class="kr">then</span> <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">line&#39;</span> <span class="n">words</span>
</span><span class='line'>                                         <span class="kr">else</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing (splitting a long paragraph into lines of at most 72 characters):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Split&gt; putStrLn $ unlines $ split 72 "Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio. Pellentesque cursus augue quis libero malesuada ornare. Phasellus interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit interdum at a purus."
</span><span class='line'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam
</span><span class='line'>nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.
</span><span class='line'>Pellentesque cursus augue quis libero malesuada ornare. Phasellus
</span><span class='line'>interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper
</span><span class='line'>posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit
</span><span class='line'>ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla
</span><span class='line'>facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit
</span><span class='line'>interdum at a purus.</span></code></pre></td></tr></table></div></figure>


<p>I used <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:unlines"><code>unlines</code></a> to group the split lines back into a single string separated by newlines and <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:putStrLn"><code>putStrLn</code></a> to print the result.</p>

<h3>Justify text</h3>

<p>The general structure of the <code>justify</code> functions is the same:</p>

<ul>
<li>compute the maximum length of all the lines</li>
<li>for each line, compute the difference between the line length and the maximum line length</li>
<li>insert spaces in the right location (depending on the kind of justification)</li>
</ul>


<p>Each justification is a specific function. First <code>pad</code> is a small utility that creates a string of spaces of the required length.</p>

<p><code>right</code> and <code>left</code> uses the above strategy to add spaces left and right, respectively. <code>center</code> adds half left, and half right. Of course <code>left</code> does not do anything visible, it just adds spaces to make each line the same length.</p>

<p><code>both</code> is more complex, as it inserts spaces between words. The strategy is naive (actual algorithms include dynamic programming to balance the amount of space), but effective.</p>

<p>The general idea is to spread the missing space between words. For this I follow these steps:</p>

<ul>
<li>split the line into words using the code from the <code>Split</code> module;</li>
<li>compute the number of interval (the count of the words minus 1). As I&#8217;m going to put the spaces between words, this interval also count as missing spaces (see next step). I refer to this amount as <code>iter</code>;</li>
<li>divide the number of missing spaces (difference between maximum line length and effective line length plus the interval): this is the amount of space I should add between each word to add up to the right amount, if I could add fractional space</li>
<li>multiply each item in <code>[1..inter]</code> by the fractional space amount as computed above.</li>
<li>iterate over the list from previous step:

<ul>
<li>compute the nearest integer of the current item (note that by construction, the nearest integer of the last item is exactly the amount of missing space);</li>
<li>the difference between this integer and the amount of space allocated so far (this amount is zero at the start, of course)</li>
<li>add a padding (using the <code>pad</code> function) to a list of spaces, and update the amount of space allocated before the next iteration</li>
</ul>
</li>
<li>then <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:zipWith"><code>zipWith</code></a> the list of spaces with the list of words, and recreate the line with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:concat"><code>concat</code></a>.</li>
</ul>


<p>The algorithm above is for a single line, but when justifying a whole paragraph, the last line should be left justified. So the <code>justify_both</code> applies the <code>both</code> justification to all but the last line, and <code>left</code> to the last line.</p>

<figure class='code'><figcaption><span> (justify.hs)</span> <a href='/downloads/code/7l7w/haskell/justify.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Justify</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Split</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- takes a justify function, a max length line (will be adjusted to max of strs lengths)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">justify</span> <span class="n">f</span> <span class="n">m</span> <span class="n">strs</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">map</span> <span class="n">length</span> <span class="n">strs</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">map</span> <span class="p">(</span><span class="n">f</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="n">strs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- when justifying both sides, the last line should be left justified</span>
</span><span class='line'><span class="nf">justify_both</span> <span class="n">m</span> <span class="n">strs</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">map</span> <span class="n">length</span> <span class="n">strs</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">map</span> <span class="p">(</span><span class="n">both</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="p">(</span><span class="n">init</span> <span class="n">strs</span> <span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">left</span> <span class="n">m&#39;</span> <span class="p">(</span><span class="n">last</span> <span class="n">strs</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">justify_left</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">left</span>
</span><span class='line'><span class="nf">justify_right</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">right</span>
</span><span class='line'><span class="nf">justify_center</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">center</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- helper functions  </span>
</span><span class='line'><span class="c1">-- create n spaces</span>
</span><span class='line'>
</span><span class='line'><span class="nf">pad</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">n</span> <span class="p">(</span><span class="n">repeat</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- Justify function helpers: add spaces at the right </span>
</span><span class='line'><span class="c1">-- location to make the length of line equal to m. </span>
</span><span class='line'><span class="c1">-- Incorrect if m is smaller than length line </span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad spaces on the right </span>
</span><span class='line'><span class="nf">left</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">line</span> <span class="o">++</span> <span class="n">pad</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad spaces on the left</span>
</span><span class='line'>
</span><span class='line'><span class="nf">right</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">pad</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="o">++</span> <span class="n">line</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad both sides by half the difference</span>
</span><span class='line'>
</span><span class='line'><span class="nf">center</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">lp</span> <span class="ow">=</span> <span class="n">floor</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>      <span class="n">rp</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">lp</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">pad</span> <span class="n">lp</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="n">pad</span> <span class="n">rp</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- justify both sides: compute the size of each interval in FRACtional value</span>
</span><span class='line'><span class="c1">-- then build a list of interval paddings with the length as close as possible</span>
</span><span class='line'><span class="c1">-- from the running sum of fractional intervals</span>
</span><span class='line'><span class="nf">both</span> <span class="n">m</span> <span class="kt">[]</span>   <span class="ow">=</span> <span class="n">pad</span> <span class="n">m</span>
</span><span class='line'><span class="nf">both</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_words</span> <span class="n">line</span>
</span><span class='line'>      <span class="n">inter</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">words</span>
</span><span class='line'>      <span class="n">addInterFrac</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">makeInter</span> <span class="n">inter</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">inter</span><span class="p">]</span>
</span><span class='line'>      <span class="n">addSpaces</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">foldl</span> <span class="n">adjust</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="n">addInterFrac</span> <span class="kr">of</span>
</span><span class='line'>                    <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">spaces</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">spaces</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">concat</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="n">addSpaces</span> <span class="n">words</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">adjust</span> <span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">spaces</span><span class="p">)</span> <span class="n">newFrac</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">diff</span> <span class="ow">=</span> <span class="n">round</span> <span class="p">(</span><span class="n">newFrac</span> <span class="o">-</span> <span class="n">fromIntegral</span> <span class="n">curr</span><span class="p">)</span>
</span><span class='line'>                                        <span class="kr">in</span> <span class="p">(</span><span class="n">curr</span> <span class="o">+</span> <span class="n">diff</span><span class="p">,</span> <span class="p">(</span><span class="n">pad</span> <span class="n">diff</span><span class="p">)</span><span class="kt">:</span><span class="n">spaces</span><span class="p">)</span>
</span><span class='line'>        <span class="n">makeInter</span> <span class="n">inter</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">i</span>
</span><span class='line'>             <span class="o">*</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span> <span class="o">+</span> <span class="n">inter</span><span class="p">))</span>
</span><span class='line'>             <span class="o">/</span> <span class="n">fromIntegral</span> <span class="n">inter</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing (the full test text is not reproduce here to save space):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*Justify&gt; putStrLn $ unlines $ justify_left 72 $ split 72 "Lorem ipsum ... a purus."
</span><span class='line'>Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam    
</span><span class='line'>nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.    
</span><span class='line'>Pellentesque cursus augue quis libero malesuada ornare. Phasellus       
</span><span class='line'>interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper     
</span><span class='line'>posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit    
</span><span class='line'>ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla    
</span><span class='line'>facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit   
</span><span class='line'>interdum at a purus.
</span><span class='line'>*Justify&gt; putStrLn $ unlines $ justify_right 72 $ split 72 "Lorem ipsum ... a purus."
</span><span class='line'> Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam
</span><span class='line'> nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.
</span><span class='line'>    Pellentesque cursus augue quis libero malesuada ornare. Phasellus
</span><span class='line'>  interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper
</span><span class='line'> posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit
</span><span class='line'> ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla
</span><span class='line'>facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit
</span><span class='line'>                                                 interdum at a purus.
</span><span class='line'>*Justify&gt; putStrLn $ unlines $ justify_center 72 $ split 72 "Lorem ipsum ... a purus."
</span><span class='line'>  Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam                                                                      
</span><span class='line'>  nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.                                                                              
</span><span class='line'>   Pellentesque cursus augue quis libero malesuada ornare. Phasellus                                                                     
</span><span class='line'>  interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper                                                                      
</span><span class='line'>  posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit                                                                      
</span><span class='line'>  ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla                                                                      
</span><span class='line'> facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit                                                                       
</span><span class='line'>                          interdum at a purus.
</span><span class='line'>*Justify&gt; putStrLn $ unlines $ justify_both 72 $ split 72 "Lorem ipsum ... a purus."
</span><span class='line'>Lorem ipsum  dolor sit  amet, consectetur adipiscing  elit. In  vel diamnunc. Proin  in justo quis  nisl aliquam  mollis. Sed vitae  dolor odio.Pellentesque  cursus  augue  quis  libero  malesuada  ornare.  Phasellus
</span><span class='line'>interdum  ultrices tincidunt.  Etiam  ullamcorper,  massa a  ullamcorper
</span><span class='line'>posuere, dolor  quam consequat  est, ut  ullamcorper elit  eros suscipit
</span><span class='line'>ante. Etiam  non quam sit  amet risus posuere  mollis non in  est. Nulla
</span><span class='line'>facilisi. Sed  ut commodo risus. Suspendisse  ut nisi ac  erat hendrerit
</span><span class='line'>interdum at a purus.</span></code></pre></td></tr></table></div></figure>


<h3>Number lines</h3>

<p>I finished with this one, as I reused some functions defined in the module <code>Justify</code> above.</p>

<p>This is much simpler than justifying. I need to know the number of digits I would need (which depends on the number of lines). Then I can right justify the line number and add it left of each line.</p>

<figure class='code'><figcaption><span> (number.hs)</span> <a href='/downloads/code/7l7w/haskell/number.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Number</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Justify</span>
</span><span class='line'>
</span><span class='line'><span class="nf">addLineNum</span> <span class="n">lines</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">md</span> <span class="ow">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="n">logBase</span> <span class="mi">10</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">lines</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="kr">in</span> <span class="n">zipWith</span> <span class="p">(</span><span class="n">lineNum</span> <span class="n">md</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="n">lines</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">lineNum</span> <span class="n">md</span> <span class="n">num</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">toStr</span> <span class="n">md</span> <span class="n">num</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">line</span>
</span><span class='line'>        <span class="n">toStr</span> <span class="n">maxDigits</span> <span class="n">num</span> <span class="ow">=</span> <span class="n">right</span> <span class="n">maxDigits</span> <span class="p">(</span><span class="n">show</span> <span class="n">num</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Testing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Prelude&gt; :l number.hs 
</span><span class='line'>[1 of 3] Compiling Split            ( Split.hs, interpreted )
</span><span class='line'>[2 of 3] Compiling Justify          ( Justify.hs, interpreted )
</span><span class='line'>[3 of 3] Compiling Number           ( number.hs, interpreted )
</span><span class='line'>Ok, modules loaded: Number, Justify, Split.
</span><span class='line'>*Number&gt; :m +Split Justify
</span><span class='line'>*Number Split Justify&gt; putStrLn $ unlines $ addLineNum $ justify\_both  72 $ split 72 "Lorem ipsum ... a purus."
</span><span class='line'>1 Lorem ipsum  dolor sit  amet, consectetur adipiscing  elit. In  vel diam
</span><span class='line'>2 nunc. Proin  in justo quis  nisl aliquam  mollis. Sed vitae  dolor odio.
</span><span class='line'>3 Pellentesque  cursus  augue  quis  libero  malesuada  ornare.  Phasellus
</span><span class='line'>4 interdum  ultrices tincidunt.  Etiam  ullamcorper,  massa a  ullamcorper
</span><span class='line'>5 posuere, dolor  quam consequat  est, ut  ullamcorper elit  eros suscipit
</span><span class='line'>6 ante. Etiam  non quam sit  amet risus posuere  mollis non in  est. Nulla
</span><span class='line'>7 facilisi. Sed  ut commodo risus. Suspendisse  ut nisi ac  erat hendrerit
</span><span class='line'>8 interdum at a purus.                                                    </span></code></pre></td></tr></table></div></figure>


<h2>Wrapping up Day 2</h2>

<p>As I knew Haskell already, this was not too taxing. I had fun with the justify challenge, trying to come up with a reasonable way to insert the right amount of space at the right place.</p>

<p>Dealing with types was also mostly painless. I had a couple of errors when trying to compile, but every time the location was well reported and the fix easy to figure out.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Frédéric Dumont</span></span>

      








  


<time datetime="2011-11-18T09:39:00+09:00" pubdate data-updated="true">Nov 18<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/books/'>Books</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/" data-via="" data-counturl="http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1/" title="Previous Post: Seven Languages in Seven Weeks Haskell Day 1">&laquo; Seven Languages in Seven Weeks Haskell Day 1</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3/" title="next Post: Seven Languages in Seven Weeks Haskell Day 3">Seven Languages in Seven Weeks Haskell Day 3 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>About Wakatta!</h1>
  <p>
		<a href="/about">more...</a>
	</p>
</section>

<section>
	<h1>Seven Languages in Seven Weeks Series</h1>
	
		<ul>
		
			<li class="post"><a href="/blog/2011/10/11/seven-languages-in-seven-weeks/">Intro</a></li>
		
			<li class="post"><a href="/blog/2011/10/11/seven-languages-in-seven-weeks-ruby-day-1/">Ruby Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/12/seven-languages-in-seven-weeks-ruby-day-2/">Ruby Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/13/seven-languages-in-seven-weeks-ruby-day-3/">Ruby Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/18/seven-languages-in-seven-weeks-io-day-1/">Io Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/19/seven-languages-in-seven-weeks-io-day-2/">Io Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/20/seven-languages-in-seven-weeks-io-day-3/">Io Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/21/seven-languages-in-seven-weeks-about-io/">About Io</a></li>
		
			<li class="post"><a href="/blog/2011/10/23/seven-languages-in-seven-weeks-prolog-day-1/">Prolog Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/23/seven-languages-in-seven-weeks-prolog-day-2/">Prolog Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/24/seven-languages-in-seven-weeks-prolog-day-3/">Prolog Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/10/28/seven-languages-in-seven-weeks-scala-day-1/">Scala Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/10/29/seven-languages-in-seven-weeks-scala-day-2/">Scala Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/10/30/seven-languages-in-seven-weeks-scala-day-3/">Scala Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/11/04/seven-languages-in-seven-weeks-erlang-day-1/">Erlang Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/05/seven-languages-in-seven-weeks-erlang-day-2/">Erlang Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/06/seven-languages-in-seven-weeks-erlang-day-3/">Erlang Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/11/11/seven-languages-in-seven-weeks-clojure-day-1/">Clojure Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/12/seven-languages-in-seven-weeks-clojure-day-2/">Clojure Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1/">Haskell Day 1</a></li>
		
			<li class="post"><a href="/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/">Haskell Day 2</a></li>
		
			<li class="post"><a href="/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3/">Haskell Day 3</a></li>
		
			<li class="post"><a href="/blog/2011/11/21/seven-languages-in-seven-weeks-haskell-day-3-dot-5/">Haskell Day 3.5</a></li>
		
			<li class="post"><a href="/blog/2011/11/26/seven-languages-in-seven-weeks-wrap-up/">Wrap Up</a></li>
		
		</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/02/13/psychic-modeling-fast-version/">Psychic Modeling (fast version)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/10/psychic-modeling/">Psychic Modeling</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/05/concrete-mathematics-chapter-1-exam-problems/">Concrete Mathematics Chapter 1 Exam Problems</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/01/seven-databases-in-seven-weeks-couchdb-day-3/">Seven Databases in Seven Weeks CouchDB Day 3</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/30/seven-databases-in-seven-weeks-couchdb-day-2/">Seven Databases in Seven Weeks CouchDB Day 2</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/fdumontmd">@fdumontmd</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'fdumontmd',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Frédéric Dumont -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<div class="tex2jax_ignore">
<script type="text/javascript">
      var disqus_shortname = 'wakatta-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/';
        var disqus_url = 'http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>
</div>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
