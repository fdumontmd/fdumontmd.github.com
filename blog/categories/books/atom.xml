<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Books | Wakatta!]]></title>
  <link href="http://blog.wakatta.jp/blog/categories/books/atom.xml" rel="self"/>
  <link href="http://blog.wakatta.jp/"/>
  <updated>2011-11-21T00:55:29+09:00</updated>
  <id>http://blog.wakatta.jp/</id>
  <author>
    <name><![CDATA[Frédéric Dumont]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Seven Languages in Seven Weeks Haskell Day 3]]></title>
    <link href="http://blog.wakatta.jp/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3/"/>
    <updated>2011-11-19T14:16:00+09:00</updated>
    <id>http://blog.wakatta.jp/blog/2011/11/19/seven-languages-in-seven-weeks-haskell-day-3</id>
    <content type="html"><![CDATA[<p>Last day with Haskell, and this time we grapple with classes and monads. That's pretty much where most beginners give up in disgust...</p>

<!--more-->


<p>And that's too bad, because both (and the rest of advanced Haskell features) are very expressive (see below the Maze problem) and powerful. But classes are unusual (and the name tends to confuse Object Oriented people), while monads appear to solve a problem that is trivial in other languages (which is not true, or mostly not true).</p>

<h2>Classes</h2>

<p>Classes are more properly understood as interfaces, but the comparison can be misleading. Class elements are types that are guaranteed to provide implementation for specific functions. Combined with polymorphism, it allows writing functions that are more intimate with their arguments, while keeping purity and referential transparency (in some sense, it plays a role similar to functors in ML languages).</p>

<p>Classes nicely support monads (and other composition mechanisms) by providing interfaces these abstractions can build upon.</p>

<h2>Monads</h2>

<p>Monads are mechanisms to compose calculations. They also happen to solve the IO problem in Haskell, which is a nice (and significant) bonus. But the calculation composition is core. With it, one can have backtracking, continuation, probabilistic computing, anything you could think off. Thinking of anything actually is quite hard, as most programmers are not used to such freedom. For IO, it just happens to guarantee linear evaluation.</p>

<p>There are a number of resources to learn about Monads (indeed, it seems the path to Haskell mastery must include at least one Monad tutorial). I found  <a href="http://monads.haskell.cz/html/">All About Monads</a> very useful. The introduction is really good, but links to this tutorial tend to disappear, unfortunately. There is also the <a href="http://book.realworldhaskell.org/read/monads.html">Monads</a> chapter of <a href="http://book.realworldhaskell.org/">Real World Haskell</a> (which you should read, but wait for the second edition to buy). This introduction is more complex, as it builds a State Monad rather than the Maybe Monad.</p>

<p>Finally, <a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a> from <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a> also covers the Maybe Monad as an introduction. I have the book but did not read it yet, so I cannot comment on it, but I have seen great reviews.</p>

<h2>Exercises</h2>

<h3>Lookup function returning Maybe</h3>

<p>The function <code>my_lookup</code> is easy; it iterates over a list of pairs key, value, and returns <code>Just value</code> when the key matches. On empty list, it returns <code>Nothing</code>. There is no need to think about monads at this point. A key,value map is really some data structure that <code>Maybe</code> contains a specific key.</p>

<p>Slightly more difficult was the <code>testData</code>. The nesting was somewhat tricky to get right.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (lookup.hs)</span> <a href='/downloads/code/7l7w/haskell/lookup.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Lookup</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_lookup</span> <span class="n">key</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="nf">my_lookup</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>  <span class="ow">=</span> <span class="kt">Just</span> <span class="n">value</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">key</span> <span class="n">rest</span>
</span><span class='line'>
</span><span class='line'><span class="nf">testData</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="kt">[]</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="s">&quot;tada!&quot;</span><span class="p">)]),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;j&quot;</span><span class="p">,</span> <span class="s">&quot;nope&quot;</span><span class="p">)])]),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="s">&quot;tada!&quot;</span><span class="p">)])])]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Once this is defined, using it with the <code>&gt;&gt;=</code> operator is really simple:</p>

<p><code>
*Lookup&gt; my_lookup 2 testData &gt;&gt;= my_lookup "a" &gt;&gt;= my_lookup "i"
Just "tada!"
*Lookup&gt; my_lookup 2 testData &gt;&gt;= my_lookup "b" &gt;&gt;= my_lookup "i"
Nothing
</code></p>

<h3>Solving Maze</h3>

<p>Using the List Monad to solve problems is very similar to using Prolog: elements in a list are alternative paths; failure (which must be explicit by calling <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:fail"><code>fail</code></a> or <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Control-Monad.html#v:guard"><code>guard</code></a>) backtracks to the next alternative; [<code>return</code>] adds a solution to the list of solutions (even if there's only one possible solution, the List Monad produces a list).</p>

<p>To solve the maze, the algorithm do the following:</p>

<ul>
<li>the <code>loop</code> subfunction is used to explore a given solution; the List Monad hides the iteration and backtracking over alternatives</li>
<li>the <code>loop</code> function is always called with the reverse path so far: the first element is actually the current position</li>
<li>if the current position is the exit position, the path is reversed then returned as solution</li>
<li>otherwise, the current node is checked, and its exits retrieved</li>
<li>the positions in the path are first removed from the exits, to avoid looping (so we never go over the same position twice)</li>
<li>the List Monad main logic starts there:

<ul>
<li>first <code>guard</code> that the list of possible exits is not empty</li>
<li>then select and alternative new position</li>
<li>call <code>loop</code> on the new path to explore it</li>
</ul>
</li>
</ul>


<p>The code is fairly short, and perhaps could be shorter. The backtracking is provided for free by the List Monad, but very effective to implement a search (I used it to solve Sudoku problems).</p>

<p>To be fair, I took some time to track a bug: instead of adding the whole current path to the recursive <code>loop</code> call, I only passed the tail. That caused <code>loop</code> to actually ignore the current path, and run in circle forever. Once fixed, the search was instantaneous.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (maze.hs)</span> <a href='/downloads/code/7l7w/haskell/maze.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Maze</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.List</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- a Maze is an array of Node</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">Maze</span> <span class="ow">=</span> <span class="p">[[</span><span class="kt">Node</span><span class="p">]]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- each node can have a number of exits (indicated by locations in the Maze)</span>
</span><span class='line'><span class="kr">data</span> <span class="kt">Node</span> <span class="ow">=</span> <span class="kt">Exits</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
</span><span class='line'>  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- solve a maze using List monad:</span>
</span><span class='line'><span class="c1">-- </span>
</span><span class='line'><span class="nf">solveMaze</span> <span class="ow">::</span> <span class="kt">Maze</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span><span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
</span><span class='line'><span class="nf">solveMaze</span> <span class="n">m</span> <span class="n">pos</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">case</span> <span class="n">loop</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</span><span class='line'>    <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">p</span>
</span><span class='line'>  <span class="kr">where</span>
</span><span class='line'>    <span class="n">loop</span> <span class="n">path</span><span class="o">@</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span>
</span><span class='line'>      <span class="kr">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">e1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">e2</span>
</span><span class='line'>      <span class="kr">then</span> <span class="n">return</span> <span class="o">$</span> <span class="n">reverse</span> <span class="n">path</span>
</span><span class='line'>      <span class="kr">else</span>
</span><span class='line'>        <span class="kr">let</span> <span class="p">(</span><span class="kt">Exits</span> <span class="n">exits</span><span class="p">)</span> <span class="ow">=</span> <span class="p">((</span><span class="n">m</span> <span class="o">!!</span> <span class="n">i</span><span class="p">)</span> <span class="o">!!</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>            <span class="n">poss</span> <span class="ow">=</span> <span class="n">exits</span> <span class="o">\\</span> <span class="n">path</span>
</span><span class='line'>        <span class="kr">in</span> <span class="kr">do</span> <span class="n">guard</span> <span class="p">(</span><span class="n">not</span> <span class="o">$</span> <span class="n">null</span> <span class="n">poss</span><span class="p">)</span>
</span><span class='line'>              <span class="n">pos</span> <span class="ow">&lt;-</span> <span class="n">poss</span>
</span><span class='line'>              <span class="n">loop</span> <span class="p">(</span><span class="n">pos</span><span class="kt">:</span><span class="n">path</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- the problem is parsed by looking at characters around</span>
</span><span class='line'><span class="c1">-- every even position (position with even x and y)</span>
</span><span class='line'><span class="c1">-- if the character in a direction is a space, there&#39;s an exit</span>
</span><span class='line'><span class="nf">parseMaze</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maze</span>
</span><span class='line'><span class="nf">parseMaze</span> <span class="n">raw</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">rows</span> <span class="ow">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">length</span> <span class="n">raw</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>      <span class="n">cols</span> <span class="ow">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">length</span> <span class="o">$</span> <span class="n">head</span> <span class="n">raw</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>  <span class="kr">in</span> <span class="p">[[</span><span class="n">makeNode</span> <span class="n">i</span> <span class="n">j</span> <span class="o">|</span> <span class="n">j</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">cols</span><span class="p">]]</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">rows</span><span class="p">]]</span>
</span><span class='line'> <span class="kr">where</span>
</span><span class='line'>  <span class="n">makeNode</span> <span class="n">i</span> <span class="n">j</span> <span class="ow">=</span> <span class="kt">Exits</span> <span class="o">$</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">makeExit</span> <span class="n">i</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>                           <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
</span><span class='line'>  <span class="n">makeExit</span> <span class="n">i</span> <span class="n">j</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">raw</span> <span class="o">!!</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!!</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span>
</span><span class='line'>                        <span class="kr">then</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
</span><span class='line'>                        <span class="kr">else</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="kr">data</span> <span class="kt">Problem</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span><span class='line'>  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- updateAt runs an update function on the nth element in a list</span>
</span><span class='line'><span class="c1">-- keeps the rest</span>
</span><span class='line'><span class="nf">updateAt</span> <span class="n">n</span> <span class="n">f</span> <span class="n">ls</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">case</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="n">ls</span> <span class="kr">of</span>
</span><span class='line'>    <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="kt">:</span><span class="n">rest</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">pre</span> <span class="o">++</span> <span class="p">((</span><span class="n">f</span> <span class="n">u</span><span class="p">)</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- update the prob description with path iteratively</span>
</span><span class='line'><span class="nf">displaySol</span> <span class="n">prob</span> <span class="n">sol</span> <span class="ow">=</span>
</span><span class='line'>  <span class="n">foldl&#39;</span> <span class="n">update</span> <span class="n">prob</span> <span class="n">sol</span>
</span><span class='line'> <span class="kr">where</span>
</span><span class='line'>  <span class="n">update</span> <span class="n">prob</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">=</span> <span class="n">updateAt</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">updateAt</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="sc">&#39;*&#39;</span><span class="p">))</span> <span class="n">prob</span>
</span><span class='line'>
</span><span class='line'><span class="nf">solveProblem</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</span><span class='line'><span class="nf">solveProblem</span> <span class="n">f</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">do</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">start</span> <span class="n">end</span> <span class="n">prob</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">readProblem</span> <span class="n">f</span>
</span><span class='line'>     <span class="kr">let</span> <span class="n">maze</span>   <span class="ow">=</span> <span class="n">parseMaze</span> <span class="n">prob</span>
</span><span class='line'>     <span class="kr">case</span> <span class="n">solveMaze</span> <span class="n">maze</span> <span class="n">start</span> <span class="n">end</span> <span class="kr">of</span>
</span><span class='line'>       <span class="kt">Just</span> <span class="n">sol</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">unlines</span> <span class="o">$</span> <span class="n">displaySol</span> <span class="n">prob</span> <span class="n">sol</span>
</span><span class='line'>       <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;no solution found&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- special code for sample mazes from</span>
</span><span class='line'><span class="c1">-- http://benjamin-meyer.blogspot.com/2005/01/ascii-maze-ment-puzzle.html</span>
</span><span class='line'><span class="nf">readProblem</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Problem</span>
</span><span class='line'><span class="nf">readProblem</span> <span class="n">f</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">do</span> <span class="n">raw</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">f</span>
</span><span class='line'>     <span class="kr">let</span> <span class="n">filtered</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">filterMaze</span> <span class="n">raw</span> <span class="kr">of</span>
</span><span class='line'>                      <span class="p">(</span><span class="n">l</span><span class="kt">:</span><span class="n">ls</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="n">init</span> <span class="o">$</span> <span class="n">init</span> <span class="n">l</span><span class="p">)</span><span class="kt">:</span><span class="n">ls</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">filtered</span><span class="p">,</span> <span class="n">length</span> <span class="p">(</span><span class="n">head</span> <span class="n">filtered</span><span class="p">))</span>
</span><span class='line'>     <span class="n">return</span> <span class="o">$</span> <span class="kt">Prob</span> <span class="p">((</span><span class="n">i</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">filtered</span>
</span><span class='line'>
</span><span class='line'><span class="nf">splitAtEvery</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
</span><span class='line'><span class="nf">splitAtEvery</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">splitAtEvery</span> <span class="n">n</span> <span class="n">ls</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">case</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="n">ls</span> <span class="kr">of</span>
</span><span class='line'>    <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">pre</span><span class="kt">:</span><span class="n">splitAtEvery</span> <span class="n">n</span> <span class="n">rest</span>
</span><span class='line'>
</span><span class='line'><span class="nf">removeExtraSpaces</span> <span class="p">(</span><span class="n">l</span><span class="kt">:</span><span class="n">ls</span><span class="p">)</span> <span class="ow">=</span> <span class="n">l</span><span class="kt">:</span><span class="p">(</span><span class="n">concatMap</span> <span class="n">tail</span> <span class="o">$</span> <span class="n">splitAtEvery</span> <span class="mi">3</span> <span class="n">ls</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">filterMaze</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">removeExtraSpaces</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">drop</span> <span class="mi">5</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The rest of the code includes a parser for a specific maze description (I found sample mazes <a href="http://benjamin-meyer.blogspot.com/2005/01/ascii-maze-ment-puzzle.html">here</a>), and code to process a problem into a <code>Maze</code> instance, and code to display a solution.</p>

<p>Testing:
```
*Maze> solveProblem "input1.txt"</p>

<hr />

<p>|   | |   |        <em>|
| <strong>| | </strong>|<strong>_  </strong>  |
|   | |       |   |</em>|
| <strong>| |</strong><strong><em>  |</em>  | |
|   | | | |       |*|
| </strong>| | | |<strong><strong><strong><em>| |
|            * * * *|
| </em></strong></strong></strong><em><strong>  </strong>    |
| |   |    * *| | | |
|</em>|   |<em><strong>  </strong>| | |</em>|
|   |     |<em>| | | | |
|<em>  |</em>    | | | |_| |
|   |   |  </em>|       |
| <strong>|<em>  |</em>  | </strong>    |
| |     |  * <em>| | | |
|<em>| <strong>  | </strong>  | |</em>|<em>|
| |   | | |  *  |   |
| |   | |</em>|<em>  __|</em>  |
|   | | |   |</em> *  | |
| <strong>|_| | </strong>|<em>    | |
| | |   |  * * *|   |
|</em>| | <strong>|_  </strong>  |<em><strong>|
| | |     |*| | |   |
| | | </strong>__| | |</em>|<em>  |
|   | |* * *        |
|</em>  |<em>|   <strong>  </strong></em><em><strong>|
|    * *| |     |   |
|     </strong>| |</em>  <strong>| </strong>|
| | |<em>  |   |   |   |
| |<em>| <strong>|</strong></em>|<em>__|</em>  |
|   |</em> <em>|     |     |
|<em><strong>|   |   </strong>| </em>___|
|   | |</em> <em>|     |   |
| <strong>|<em>|</em>  |     | </strong>|
|       |</em>| | |     |
|<em><strong><em><em>  | |</em>| |</em>  </strong>|
|<em> * </em>|  *|     |   |
|     |</em>  | <strong>  |   |
|<em>| |</em> * *|   | | | |
|<em>|</em>|</strong><strong><em>|</em></strong>|<em>|</em>|_|
```</p>

<h2>Wrapping up Day 3 and Haskell</h2>

<p>The exercises (ok, just the maze one) were challenging and show or at least hint at Haskell strength: the ability to compose calculations from basic elements and add advanced control mechanisms almost transparently.</p>

<p>I enjoy Haskell; it allows to think at a higher level, to see computations from different angles, in a way that expands the mind (sometimes painfully). And while it is certainly not mainstream, there are high quality niches (banking and financial companies) that justify investing (stupid pun intended) in Haskell.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seven Languages in Seven Weeks Haskell Day 2]]></title>
    <link href="http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2/"/>
    <updated>2011-11-18T09:39:00+09:00</updated>
    <id>http://blog.wakatta.jp/blog/2011/11/18/seven-languages-in-seven-weeks-haskell-day-2</id>
    <content type="html"><![CDATA[<p>Today introduces the functional aspects of Haskell: higher order functions, partial application of functions and lazy evaluation.</p>

<!--more-->


<p>Higher order functions should no longer be surprising: many languages have that, even if Haskell other features make them very easy to use.</p>

<p>Partial application is such a feature. A function can be passed some, but not all its arguments, meaning that it is still a function, not a value. It reduces the number of anonymous functions one needs to write when using higher order functions.</p>

<p>Lazy evaluation is something very unique (among the lazy languages, only Haskell is somewhat mainstream). Clojure has lazy lists, which is cool, but lazy evaluation applies to everything. A piece of data can refer to itself in its definition, as long as the part that is needed can be evaluated before the part it depends on.</p>

<p>For instance, a canonical definition of the Fibonacci sequence is
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Fibonacci sequence  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>fibs</code> list is the list of Fibonacci numbers. It starts with 1, 1, then the list of itself summed with its own tail... but the 3rd number depends on the first and the second, so its ok. By the time we need to compute the 4th, the 3rd is already known, and so on.</p>

<p>It takes but an instant to compute the 100000th number in the sequence:
<code>
*Parse&gt; fibs !! 100000
42026927029951543863190051012939151317739157026322345033047..... -- number truncated to save space
</code></p>

<p>Which brings me to a remark on the book: why on earth is <code>fibNth</code> defined the way it is? That function exists, and is called <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:-33--33-"><code>!!</code></a>. The code in the book is convoluted, does not need that many parenthesis, and even if you have a problem with <code>!!</code>, there is no need to use both <code>take</code> and <code>drop</code> if you're going to take the <code>head</code> of the result (<code>take</code> will make a copy of the list for no good reason).</p>

<h2>Exercises</h2>

<p>In general I tried to avoid standard functions that implement a significant portion of the intended behaviour. So I didn't use <code>sort</code> in my sort function, or <code>read</code> in parsing, ...</p>

<h3>Simple sort</h3>

<p>A good sort algorithm is always tricky, but insertion sort is simple enough and easy to express with pattern matching. My implementation has the same signature as the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-List.html#v:sort"><code>sort</code></a> function. It expects is arguments to have the class <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#t:Ord"><code>Ord</code></a>s, which guarantees they can be compared.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mysort.hs)</span> <a href='/downloads/code/7l7w/haskell/mysort.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">MySort</span> <span class="kr">where</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Ord</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_sort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">my_sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_insert</span> <span class="n">x</span> <span class="o">$</span> <span class="n">my_sort</span> <span class="n">xs</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">my_insert</span> <span class="n">x</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span><span class='line'>        <span class="n">my_insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>        <span class="ow">=</span> <span class="n">y</span><span class="kt">:</span><span class="n">my_insert</span> <span class="n">x</span> <span class="n">ys</span>
</span><span class='line'>                           <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing it:</p>

<p><code>
*MySort&gt; my_sort ([1..10] ++ [10, 9.. 1])
[1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
</code></p>

<h3>Sort using comparison function</h3>

<p>Sort using a specific comparison function is not harder. The standard implementation uses <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#t:Ordering"><code>Data.Ord.Ordering</code></a> to replace <code>&gt;</code> by the comparison result <code>GT</code>. My implementation has the same signature as the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-List.html#v:sortBy"><code>sortBy</code></a>, but still uses the insertion sort as in <code>my_sort</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (mysortby.hs)</span> <a href='/downloads/code/7l7w/haskell/mysortby.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">MySort</span> <span class="kr">where</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Ord</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="kr">_</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">my_sort_by</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="o">$</span> <span class="n">my_sort_by</span> <span class="n">f</span> <span class="n">xs</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">my_insert_by</span> <span class="kr">_</span> <span class="n">x</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span><span class='line'>        <span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">==</span> <span class="kt">GT</span> <span class="ow">=</span> <span class="n">y</span><span class="kt">:</span><span class="n">my_insert_by</span> <span class="n">f</span> <span class="n">x</span> <span class="n">ys</span>
</span><span class='line'>                                <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing it (using <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Ord.html#v:compare"><code>compare</code></a> on the absolute value):
<code>
*MySort&gt; my_sort_by (\a b -&gt; compare (abs a) (abs b)) ([10, 9..1] ++ [-10..(-1)])
[1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10]
</code></p>

<h3>Parse string into number</h3>

<p>Parsing is not hard; to do it I break the string into a integral part, and the fractional part. Both are then cleaned to remove non digits.</p>

<p>The integral part is parsed left to right (with <code>foldl</code>), each time multiplying the already parsed number by 10 before adding the current number.</p>

<p>The fractional part is parsed right to left (with <code>foldr</code>), dividing the already parsed number by 10 before adding the current number.</p>

<p>Note the use of <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:fromIntegral"><code>fromIntegral</code></a> function. This is used to convert and integral number (<code>Int</code>, <code>Integer</code>, ...) into any type of number. This is necessary to be allowed to divide the results and add the fractional part.</p>

<p>The use of fractional arithmetic makes this function less effective than <code>read</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (parse.hs)</span> <a href='/downloads/code/7l7w/haskell/parse.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Parse</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Char</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.List</span>
</span><span class='line'>
</span><span class='line'><span class="nf">parse</span> <span class="n">str</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="p">(</span><span class="n">dig</span><span class="p">,</span> <span class="n">frac</span><span class="p">)</span> <span class="ow">=</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="n">str</span>
</span><span class='line'>    <span class="kr">in</span> <span class="n">foldl&#39;</span> <span class="n">pDig</span> <span class="mi">0</span> <span class="p">(</span><span class="n">clean</span> <span class="n">dig</span><span class="p">)</span> <span class="o">+</span> <span class="n">foldr</span> <span class="n">pFrac</span> <span class="mi">0</span> <span class="p">(</span><span class="n">clean</span> <span class="n">frac</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span>
</span><span class='line'>
</span><span class='line'><span class="nf">clean</span> <span class="n">s</span>   <span class="ow">=</span> <span class="n">filter</span> <span class="n">isDigit</span> <span class="n">s</span>
</span><span class='line'><span class="nf">pDig</span>  <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">toNum</span> <span class="n">b</span>
</span><span class='line'><span class="nf">pFrac</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">toNum</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">/</span><span class="mi">10</span>
</span><span class='line'><span class="nf">toNum</span> <span class="n">c</span>   <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">ord</span> <span class="n">c</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">&#39;0&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing:
<code>
*Parse&gt; parse "$2,345,678.99"
2345678.99
*Parse&gt; parse "2,345"
2345.0
*Parse&gt; parse ".99"
0.99
*Parse&gt; parse ".234"
0.23399999999999999
</code></p>

<h3>Lazy sequences</h3>

<p>Once again, nothing difficult. Haskell notation pretty much reads as a specification of the problem:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (lazy.hs)</span> <a href='/downloads/code/7l7w/haskell/lazy.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Lazy</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">thirds</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="o">..</span><span class="p">]</span>
</span><span class='line'><span class="nf">fifths</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">5</span><span class="o">..</span><span class="p">]</span>
</span><span class='line'><span class="nf">eighths</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">thirds</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fifths</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing:
<code>
*Lazy&gt; take 10 $ thirds 10
[10,13,16,19,22,25,28,31,34,37]
*Lazy&gt; take 10 $ fifths 20
[20,25,30,35,40,45,50,55,60,65]
*Lazy&gt; take 10 $ eighths 10 20
[30,38,46,54,62,70,78,86,94,102]
</code></p>

<h3>Partial application</h3>

<p>Notice the use of partial application of operators: if you wrap the operator and its argument in parenthesis (they are needed here), you have a function that takes the missing argument. The missing argument can be the left one as see here.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (partial.hs)</span> <a href='/downloads/code/7l7w/haskell/partial.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Partial</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">half</span> <span class="ow">=</span> <span class="p">(</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">terminate</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing:</p>

<p><code>
*Partial&gt; half 10
5.0
*Partial&gt; terminate "Hello"
"Hello\n"
</code></p>

<h2>Challenges</h2>

<h3>Greatest Common Denominator</h3>

<p>I must have missed something, because that was hardly a challenge. I just implemented the <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (gcd.hs)</span> <a href='/downloads/code/7l7w/haskell/gcd.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">GCD</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- Euclidean algorithm</span>
</span><span class='line'><span class="nf">my_gcd</span> <span class="n">m</span> <span class="n">n</span> <span class="o">|</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span>     <span class="ow">=</span> <span class="n">my_gcd</span> <span class="n">n</span> <span class="n">m</span>
</span><span class='line'>           <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>    <span class="ow">=</span> <span class="n">m</span>
</span><span class='line'>           <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">my_gcd</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing:
<code>
*GCD&gt; my_gcd 1961 901
53
*GCD&gt; my_gcd 901 1961
53
*GCD&gt; gcd 1961 901
53
</code></p>

<p><code>my_gcd</code> agrees with the standard <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:gcd"><code>gcd</code></a> function.</p>

<h3>Lazy prime number sequences</h3>

<p>This one was a bit trickier, yet an implementation that closely follows the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> algorithm is fairly short.</p>

<p>I first need a difference function that works on infinite lists: I manage this by taking into account the fact that the lists are always sorted. The <code>minus</code> just compares the first item of its arguments, so it can work linearly on both of them. Note that this function is not able to work on finite lists, but in this context there is no need to.</p>

<p>The implementation follows the proposed optimizations: it puts 2 in the prime number list right from the start, and skips other even numbers. It also start filtering at <code>p*p</code>, as smaller multiples have been filtered already (being a multiple of smaller prime numbers).</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (sieve.hs)</span> <a href='/downloads/code/7l7w/haskell/sieve.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Sieve</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="nf">minus</span> <span class="n">xl</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">yl</span><span class="o">@</span><span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">minus</span> <span class="n">xs</span> <span class="n">ys</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>     <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">minus</span> <span class="n">xs</span> <span class="n">yl</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">minus</span> <span class="n">xl</span> <span class="n">ys</span>
</span><span class='line'>
</span><span class='line'><span class="nf">primes</span> <span class="ow">=</span> <span class="mi">2</span><span class="kt">:</span><span class="n">sieve</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span> <span class="o">..</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">sieve</span> <span class="p">(</span><span class="n">p</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">p</span><span class="kt">:</span><span class="n">sieve</span> <span class="p">(</span><span class="n">xs</span> <span class="p">`</span><span class="n">minus</span><span class="p">`</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">p</span> <span class="o">..</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The implementation is very slow, but can compute the first 1000 prime numbers.</p>

<p><code>
*Sieve&gt; primes !! 1000
7927
</code></p>

<p>This turns out to be the first implementation on the Prime Number generator <a href="http://www.haskell.org/haskellwiki/Prime_numbers">page</a> on the Haskell wiki. Other implementations are much smarter and faster.</p>

<h3>Breaking string into lines</h3>

<p>The exercise description seems to be missing something: a line length. So I have added that to the functions.</p>

<p>Breaking into words is best done with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:words"><code>words</code></a>, but I implemented my version. I actually started with a first abstraction, not really necessary here, that splits a sequence based on a predicate (items that return true for the predicate are all removed). Then <code>my_words</code> is just calling that function with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Char.html#v:isSpace"><code>isSpace</code></a> as the predicate.</p>

<p>To combine words back into lines, I used two small functions: one (<code>accumUntil</code>) builds a line one word at a time, and stops when the line is too long. It starts with a word as the first tentative line, to make sure that a line is not empty even if a word is too long to fit.</p>

<p>The other function (<code>loop</code>) uses the previous one to build a list of lines until the list of words is empty.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (split.hs)</span> <a href='/downloads/code/7l7w/haskell/split.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Split</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Data.Char</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- generalize words and lines: remove extra break characters at the start,</span>
</span><span class='line'><span class="c1">-- then split at the next break characters; recurse on the rest</span>
</span><span class='line'>
</span><span class='line'><span class="nf">breakAtEvery</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">dropWhile</span> <span class="n">f</span> <span class="n">xs</span> <span class="kr">of</span>
</span><span class='line'>                      <span class="kt">[]</span>  <span class="ow">-&gt;</span> <span class="kt">[]</span>
</span><span class='line'>                      <span class="n">xs&#39;</span> <span class="ow">-&gt;</span> <span class="n">p</span><span class="kt">:</span><span class="n">breakAtEvery</span> <span class="n">f</span> <span class="n">r</span>
</span><span class='line'>                        <span class="kr">where</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">break</span> <span class="n">f</span> <span class="n">xs&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="nf">my_words</span> <span class="ow">=</span> <span class="n">breakAtEvery</span> <span class="n">isSpace</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- loop iterate over lines built by accumUntil</span>
</span><span class='line'><span class="c1">-- accumUntil builds a line (at least one word) and adds words</span>
</span><span class='line'><span class="c1">-- until the length is too long</span>
</span><span class='line'>
</span><span class='line'><span class="nf">split</span> <span class="n">m</span> <span class="n">str</span> <span class="ow">=</span> <span class="n">loop</span> <span class="o">$</span> <span class="n">my_words</span> <span class="n">str</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">loop</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'>        <span class="n">loop</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">w</span> <span class="n">words</span> <span class="kr">of</span>
</span><span class='line'>                           <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
</span><span class='line'>                           <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">line</span><span class="kt">:</span><span class="n">loop</span> <span class="n">rest</span>
</span><span class='line'>        <span class="n">accumUntil</span> <span class="kr">_</span> <span class="n">line</span> <span class="kt">[]</span>        <span class="ow">=</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class='line'>        <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">line</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">line&#39;</span> <span class="ow">=</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">w</span>
</span><span class='line'>                                      <span class="kr">in</span> <span class="kr">if</span> <span class="p">(</span><span class="n">length</span> <span class="n">line&#39;</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span>
</span><span class='line'>                                         <span class="kr">then</span> <span class="n">accumUntil</span> <span class="n">m</span> <span class="n">line&#39;</span> <span class="n">words</span>
</span><span class='line'>                                         <span class="kr">else</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing (splitting a long paragraph into lines of at most 72 characters):</p>

<p><code>
*Split&gt; putStrLn $ unlines $ split 72 "Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio. Pellentesque cursus augue quis libero malesuada ornare. Phasellus interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit interdum at a purus."
Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam
nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.
Pellentesque cursus augue quis libero malesuada ornare. Phasellus
interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper
posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit
ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla
facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit
interdum at a purus.
</code></p>

<p>I used <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:unlines"><code>unlines</code></a> to group the split lines back into a single string separated by newlines and <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:putStrLn"><code>putStrLn</code></a> to print the result.</p>

<h3>Justify text</h3>

<p>The general structure of the <code>justify</code> functions is the same:</p>

<ul>
<li>compute the maximum length of all the lines</li>
<li>for each line, compute the difference between the line length and the maximum line length</li>
<li>insert spaces in the right location (depending on the kind of justification)</li>
</ul>


<p>Each justification is a specific function. First <code>pad</code> is a small utility that creates a string of spaces of the required length.</p>

<p><code>right</code> and <code>left</code> uses the above strategy to add spaces left and right, respectively. <code>center</code> adds half left, and half right. Of course <code>left</code> does not do anything visible, it just adds spaces to make each line the same length.</p>

<p><code>both</code> is more complex, as it inserts spaces between words. The strategy is naive (actual algorithms include dynamic programming to balance the amount of space), but effective.</p>

<p>The general idea is to spread the missing space between words. For this I follow these steps:</p>

<ul>
<li>split the line into words using the code from the <code>Split</code> module;</li>
<li>compute the number of interval (the count of the words minus 1). As I'm going to put the spaces between words, this interval also count as missing spaces (see next step). I refer to this amount as <code>iter</code>;</li>
<li>divide the number of missing spaces (difference between maximum line length and effective line length plus the interval): this is the amount of space I should add between each word to add up to the right amount, if I could add fractional space</li>
<li>multiply each item in <code>[1..inter]</code> by the fractional space amount as computed above.</li>
<li>iterate over the list from previous step:

<ul>
<li>compute the nearest integer of the current item (note that by construction, the nearest integer of the last item is exactly the amount of missing space);</li>
<li>the difference between this integer and the amount of space allocated so far (this amount is zero at the start, of course)</li>
<li>add a padding (using the <code>pad</code> function) to a list of spaces, and update the amount of space allocated before the next iteration</li>
</ul>
</li>
<li>then <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:zipWith"><code>zipWith</code></a> the list of spaces with the list of words, and recreate the line with <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Prelude.html#v:concat"><code>concat</code></a>.</li>
</ul>


<p>The algorithm above is for a single line, but when justifying a whole paragraph, the last line should be left justified. So the <code>justify_both</code> applies the <code>both</code> justification to all but the last line, and <code>left</code> to the last line.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (justify.hs)</span> <a href='/downloads/code/7l7w/haskell/justify.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Justify</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Split</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- takes a justify function, a max length line (will be adjusted to max of strs lengths)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">justify</span> <span class="n">f</span> <span class="n">m</span> <span class="n">strs</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">map</span> <span class="n">length</span> <span class="n">strs</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">map</span> <span class="p">(</span><span class="n">f</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="n">strs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- when justifying both sides, the last line should be left justified</span>
</span><span class='line'><span class="nf">justify_both</span> <span class="n">m</span> <span class="n">strs</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">m&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">map</span> <span class="n">length</span> <span class="n">strs</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">map</span> <span class="p">(</span><span class="n">both</span> <span class="n">m&#39;</span><span class="p">)</span> <span class="p">(</span><span class="n">init</span> <span class="n">strs</span> <span class="p">)</span> <span class="o">++</span> <span class="p">[</span><span class="n">left</span> <span class="n">m&#39;</span> <span class="p">(</span><span class="n">last</span> <span class="n">strs</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">justify_left</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">left</span>
</span><span class='line'><span class="nf">justify_right</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">right</span>
</span><span class='line'><span class="nf">justify_center</span> <span class="ow">=</span> <span class="n">justify</span> <span class="n">center</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- helper functions  </span>
</span><span class='line'><span class="c1">-- create n spaces</span>
</span><span class='line'>
</span><span class='line'><span class="nf">pad</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">n</span> <span class="p">(</span><span class="n">repeat</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- Justify function helpers: add spaces at the right </span>
</span><span class='line'><span class="c1">-- location to make the length of line equal to m. </span>
</span><span class='line'><span class="c1">-- Incorrect if m is smaller than length line </span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad spaces on the right </span>
</span><span class='line'><span class="nf">left</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">line</span> <span class="o">++</span> <span class="n">pad</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad spaces on the left</span>
</span><span class='line'>
</span><span class='line'><span class="nf">right</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">pad</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="o">++</span> <span class="n">line</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- pad both sides by half the difference</span>
</span><span class='line'>
</span><span class='line'><span class="nf">center</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">lp</span> <span class="ow">=</span> <span class="n">floor</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>      <span class="n">rp</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">lp</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">pad</span> <span class="n">lp</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="n">pad</span> <span class="n">rp</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- justify both sides: compute the size of each interval in FRACtional value</span>
</span><span class='line'><span class="c1">-- then build a list of interval paddings with the length as close as possible</span>
</span><span class='line'><span class="c1">-- from the running sum of fractional intervals</span>
</span><span class='line'><span class="nf">both</span> <span class="n">m</span> <span class="kt">[]</span>   <span class="ow">=</span> <span class="n">pad</span> <span class="n">m</span>
</span><span class='line'><span class="nf">both</span> <span class="n">m</span> <span class="n">line</span> <span class="ow">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">words</span><span class="p">)</span> <span class="ow">=</span> <span class="n">my_words</span> <span class="n">line</span>
</span><span class='line'>      <span class="n">inter</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">words</span>
</span><span class='line'>      <span class="n">addInterFrac</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">makeInter</span> <span class="n">inter</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">inter</span><span class="p">]</span>
</span><span class='line'>      <span class="n">addSpaces</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">foldl</span> <span class="n">adjust</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="n">addInterFrac</span> <span class="kr">of</span>
</span><span class='line'>                    <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">spaces</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">spaces</span>
</span><span class='line'>  <span class="kr">in</span> <span class="n">concat</span> <span class="p">(</span><span class="n">w</span><span class="kt">:</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="n">addSpaces</span> <span class="n">words</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">adjust</span> <span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">spaces</span><span class="p">)</span> <span class="n">newFrac</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">diff</span> <span class="ow">=</span> <span class="n">round</span> <span class="p">(</span><span class="n">newFrac</span> <span class="o">-</span> <span class="n">fromIntegral</span> <span class="n">curr</span><span class="p">)</span>
</span><span class='line'>                                        <span class="kr">in</span> <span class="p">(</span><span class="n">curr</span> <span class="o">+</span> <span class="n">diff</span><span class="p">,</span> <span class="p">(</span><span class="n">pad</span> <span class="n">diff</span><span class="p">)</span><span class="kt">:</span><span class="n">spaces</span><span class="p">)</span>
</span><span class='line'>        <span class="n">makeInter</span> <span class="n">inter</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">i</span>
</span><span class='line'>             <span class="o">*</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">length</span> <span class="n">line</span> <span class="o">+</span> <span class="n">inter</span><span class="p">))</span>
</span><span class='line'>             <span class="o">/</span> <span class="n">fromIntegral</span> <span class="n">inter</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing (the full test text is not reproduce here to save space):</p>

<p>```
<em>Justify> putStrLn $ unlines $ justify_left 72 $ split 72 "Lorem ipsum ... a purus."
Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam  <br/>
nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.  <br/>
Pellentesque cursus augue quis libero malesuada ornare. Phasellus     <br/>
interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper   <br/>
posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit  <br/>
ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla  <br/>
facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit <br/>
interdum at a purus.
</em>Justify> putStrLn $ unlines $ justify_right 72 $ split 72 "Lorem ipsum ... a purus."
 Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam
 nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.</p>

<pre><code>Pellentesque cursus augue quis libero malesuada ornare. Phasellus
</code></pre>

<p>  interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper
 posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit
 ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla
facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit</p>

<pre><code>                                             interdum at a purus.
</code></pre>

<p>*Justify> putStrLn $ unlines $ justify_center 72 $ split 72 "Lorem ipsum ... a purus."
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel diam                                                                    <br/>
  nunc. Proin in justo quis nisl aliquam mollis. Sed vitae dolor odio.                                                                            <br/>
   Pellentesque cursus augue quis libero malesuada ornare. Phasellus                                                                   <br/>
  interdum ultrices tincidunt. Etiam ullamcorper, massa a ullamcorper                                                                    <br/>
  posuere, dolor quam consequat est, ut ullamcorper elit eros suscipit                                                                    <br/>
  ante. Etiam non quam sit amet risus posuere mollis non in est. Nulla                                                                    <br/>
 facilisi. Sed ut commodo risus. Suspendisse ut nisi ac erat hendrerit</p>

<pre><code>                      interdum at a purus.
</code></pre>

<p>*Justify> putStrLn $ unlines $ justify_both 72 $ split 72 "Lorem ipsum ... a purus."
Lorem ipsum  dolor sit  amet, consectetur adipiscing  elit. In  vel diamnunc. Proin  in justo quis  nisl aliquam  mollis. Sed vitae  dolor odio.Pellentesque  cursus  augue  quis  libero  malesuada  ornare.  Phasellus
interdum  ultrices tincidunt.  Etiam  ullamcorper,  massa a  ullamcorper
posuere, dolor  quam consequat  est, ut  ullamcorper elit  eros suscipit
ante. Etiam  non quam sit  amet risus posuere  mollis non in  est. Nulla
facilisi. Sed  ut commodo risus. Suspendisse  ut nisi ac  erat hendrerit
interdum at a purus.
```</p>

<h3>Number lines</h3>

<p>I finished with this one, as I reused some functions defined in the module <code>Justify</code> above.</p>

<p>This is much simpler than justifying. I need to know the number of digits I would need (which depends on the number of lines). Then I can right justify the line number and add it left of each line.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (number.hs)</span> <a href='/downloads/code/7l7w/haskell/number.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Number</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Justify</span>
</span><span class='line'>
</span><span class='line'><span class="nf">addLineNum</span> <span class="n">lines</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">md</span> <span class="ow">=</span> <span class="n">floor</span> <span class="o">$</span> <span class="n">logBase</span> <span class="mi">10</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">lines</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="kr">in</span> <span class="n">zipWith</span> <span class="p">(</span><span class="n">lineNum</span> <span class="n">md</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="n">lines</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">lineNum</span> <span class="n">md</span> <span class="n">num</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">toStr</span> <span class="n">md</span> <span class="n">num</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">line</span>
</span><span class='line'>        <span class="n">toStr</span> <span class="n">maxDigits</span> <span class="n">num</span> <span class="ow">=</span> <span class="n">right</span> <span class="n">maxDigits</span> <span class="p">(</span><span class="n">show</span> <span class="n">num</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing:
<code>
Prelude&gt; :l number.hs
[1 of 3] Compiling Split            ( Split.hs, interpreted )
[2 of 3] Compiling Justify          ( Justify.hs, interpreted )
[3 of 3] Compiling Number           ( number.hs, interpreted )
Ok, modules loaded: Number, Justify, Split.
*Number&gt; :m +Split Justify
*Number Split Justify&gt; putStrLn $ unlines $ addLineNum $ justify_both  72 $ split 72 "Lorem ipsum ... a purus."
1 Lorem ipsum  dolor sit  amet, consectetur adipiscing  elit. In  vel diam
2 nunc. Proin  in justo quis  nisl aliquam  mollis. Sed vitae  dolor odio.
3 Pellentesque  cursus  augue  quis  libero  malesuada  ornare.  Phasellus
4 interdum  ultrices tincidunt.  Etiam  ullamcorper,  massa a  ullamcorper
5 posuere, dolor  quam consequat  est, ut  ullamcorper elit  eros suscipit
6 ante. Etiam  non quam sit  amet risus posuere  mollis non in  est. Nulla
7 facilisi. Sed  ut commodo risus. Suspendisse  ut nisi ac  erat hendrerit
8 interdum at a purus.                                                    
</code></p>

<h2>Wrapping up Day 2</h2>

<p>As I knew Haskell already, this was not too taxing. I had fun with the justify challenge, trying to come up with a reasonable way to insert the right amount of space at the right place.</p>

<p>Dealing with types was also mostly painless. I had a couple of errors when trying to compile, but every time the location was well reported and the fix easy to figure out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seven Languages in Seven Weeks Haskell Day 1]]></title>
    <link href="http://blog.wakatta.jp/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1/"/>
    <updated>2011-11-17T07:58:00+09:00</updated>
    <id>http://blog.wakatta.jp/blog/2011/11/17/seven-languages-in-seven-weeks-haskell-day-1</id>
    <content type="html"><![CDATA[<p>The final language of the book is Haskell. Haskell is challenging and satisfying in many ways. It can be elegant and slow, or, in the hands of experts, elegant and fast (ugly but fast is usually for intermediate users).</p>

<!--more-->


<p>I had learned Haskell already, so I did not really benefit from this chapter. Still, some of the exercises were fun (and I tried to improve those that were not).</p>

<h3>On 4 + 1.0</h3>

<p>The book does not explain what happens in this expression, but I believe there is something deep and cool about Haskell here. When typing <code>4 + 1.0</code> in ghci, the output comes back as <code>5.0</code>, as expected. But the actual behaviour is not exactly usual.</p>

<p>Most languages would do that kind of processing:</p>

<ul>
<li>when parsing, 4 is tagged as integer, while 1.0 is tagged as float;</li>
<li>at runtime, the operator <code>+</code> checks its arguments:

<ul>
<li>if the types are different, it promotes the argument with the least general type to the other type. In this case, 4 is promoted to float;</li>
<li>then it call the addition routine for the correct type.</li>
</ul>
</li>
</ul>


<p>Haskell does nothing like that. The type of <code>+</code> is <code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code>. In other words, its arguments must have the same type (it is similar to Ocaml in this regard). Yet the operation succeeds.</p>

<p>This is because what the parser does is similar to replacing the numeric literal by a call to the <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:read"><code>read</code></a> function, with just enough constraints on the type to be compatible with the syntax of the literal.</p>

<p>Let's look at that <code>read</code> function. First of all, it cannot be called with no type constraint:</p>

<p>```
Prelude> read "4.0" :: Int
*** Exception: Prelude.read: no parse
Prelude> read "a"</p>

<p><interactive>:1:1:</p>

<pre><code>Ambiguous type variable `a0' in the constraint:
  (Read a0) arising from a use of `read'
Probable fix: add a type signature that fixes these type variable(s)
In the expression: read "a"
In an equation for `it': it = read "a"
</code></pre>

<p>```</p>

<p>What Haskell says here (quite forcefully) is that it does not know how to interpret the string "4" without a specific type to guide it. Lets give it one:</p>

<p><code>
Prelude&gt; read "4" :: Int
4
</code></p>

<p>If we propose to read "4" as an <code>Int</code>, <code>read "4"</code> returns an <code>Int</code> of value 4. We can try with other types:</p>

<p><code>
Prelude&gt; read "4" :: Float
4.0
</code></p>

<p>Same thing here: we constraint the value of <code>read "4"</code> to be a <code>Float</code>, so it is one. Notice how the type system can feed constraints back into a function through the return value.</p>

<p>So what happened in <code>4 + 1.0</code>? The parser replaced the literals by calls to <code>read</code>, with constraints on literals whose syntax cannot be an Integral value (such as 1.0, which indicates a <code>Float</code>). So what is really executed is</p>

<p><code>
Prelude&gt; read "4" + (read "1.0" :: Float)
5.0
</code></p>

<p>The <code>+</code> operator constraints both operands to the same type, so <code>read "4"</code> receives the constraint <code>:: Float</code> as well; both operands have the same type, always. There is no implicit conversion happening at run time.</p>

<h3>On ranges</h3>

<p>The book mentions that ranges can be built with fractional numbers, but this is really a bad idea. Haskell does support it, but will use float arithmetic, which has notorious problems for such usage. Consider this:
<code>
Prelude&gt; [1, 0.9 .. 0]
[1.0,0.9,0.8,0.7000000000000001,0.6000000000000001,0.5000000000000001,0.40000000000000013,0.30000000000000016,0.20000000000000018,0.1000000000000002,2.220446049250313e-16]
Prelude&gt;
Prelude&gt; map (/ 10) [10, 9 .. 0]
[1.0,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1,0.0]
Prelude&gt;
</code></p>

<p>The first version (fractional ranges) accumulates small errors, but the second version (integral ranges mapped into fractional ranges) is correct.</p>

<h2>Exercises</h2>

<h3>The Haskell wiki</h3>

<p>The wiki is <a href="http://haskell.org/haskellwiki/Haskell">here</a>.</p>

<h3>allEven</h3>

<p>I have 6 (or 7) variants of <code>allEven</code>. The most natural one is <code>allEven_2'</code>, based on <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:filter"><code>filter</code></a>. <code>allEven_5</code> is the same as the book version, but abstract the recursion away in <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr"><code>foldr</code></a>. <code>allEven_6</code> is strict, which means it does not work on infinite list. I tried to explain how it works <a href="/blog/2011/11/11/haskell-foldr-as-foldl/">here</a>. Of course there would never be any good reason to use anything like it, it is merely the kind of jokes Haskell programmers (some of them at least) enjoy (some of the time).</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (alleven.hs)</span> <a href='/downloads/code/7l7w/haskell/alleven.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">AllEven</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- basic definition</span>
</span><span class='line'><span class="nf">allEven</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
</span><span class='line'><span class="nf">allEven</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">allEven</span> <span class="p">(</span><span class="n">h</span><span class="kt">:</span><span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">h</span> <span class="kr">then</span> <span class="n">h</span><span class="kt">:</span><span class="n">allEven</span> <span class="n">t</span> <span class="kr">else</span> <span class="n">allEven</span> <span class="n">t</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- essentially we are filtering, so maybe a filter function would help</span>
</span><span class='line'><span class="nf">my_filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">my_filter</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">my_filter</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span><span class="kt">:</span><span class="n">my_filter</span> <span class="n">f</span> <span class="n">xs</span> <span class="kr">else</span> <span class="n">my_filter</span> <span class="n">f</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- so now we can use the my_filter function to write a new allEven:</span>
</span><span class='line'><span class="nf">allEven_2</span> <span class="n">ls</span> <span class="ow">=</span> <span class="n">my_filter</span> <span class="n">even</span> <span class="n">ls</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- in point free notation,</span>
</span><span class='line'><span class="nf">allEven_2&#39;</span> <span class="ow">=</span> <span class="n">my_filter</span> <span class="n">even</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- actually, filter already exists:</span>
</span><span class='line'><span class="nf">allEven_filter</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">even</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- if even numbers are replaced by a singleton, and odd numbers </span>
</span><span class='line'><span class="c1">-- by an empty list, when we concatenate, we get the result we want</span>
</span><span class='line'><span class="nf">allEven_3</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- concat . map == concatMap</span>
</span><span class='line'><span class="nf">allEven_4</span> <span class="ow">=</span> <span class="n">concatMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- processing lists left to right is a job for foldr. </span>
</span><span class='line'><span class="c1">-- Actually this is closer to the original definition</span>
</span><span class='line'><span class="nf">allEven_5</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="kr">else</span> <span class="n">xs</span><span class="p">)</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- accumulator and tail recursive version of allEven_5</span>
</span><span class='line'><span class="nf">allEven_6</span> <span class="n">ls</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">g</span> <span class="n">b</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span> <span class="n">x</span><span class="p">))</span> <span class="n">id</span> <span class="n">ls</span> <span class="kt">[]</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">f</span> <span class="n">x</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span> <span class="kr">else</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- list comprehension</span>
</span><span class='line'><span class="nf">allEven_7</span> <span class="n">ls</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">ls</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>reverse</h3>

<p>The natural way would of course to use <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:reverse"><code>reverse</code></a>. <code>reverse_1</code> is the one most beginners would think of. <code>reverse_2</code> uses an accumulator, which is abstracted in the <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldl"><code>foldl</code></a> function, as seen in <code>reverse_3</code> or <code>reverse_4</code>. Finally, <code>reverse_5</code> is the same kind of joke as <code>allEven_6</code> above, based on expressing <code>foldl</code> in terms <code>foldr</code>, as I explained <a href="/blog/2011/11/09/haskell-foldl-as-foldr/">here</a>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (myreverse.hs)</span> <a href='/downloads/code/7l7w/haskell/myreverse.hs'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">MyReverse</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- the naive way</span>
</span><span class='line'><span class="nf">reverse_1</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'><span class="nf">reverse_1</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">reverse_1</span> <span class="n">xs</span>  <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- accumulator and tail recursion</span>
</span><span class='line'><span class="nf">reverse_2</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">go</span> <span class="kt">[]</span> <span class="n">xs</span>
</span><span class='line'>  <span class="kr">where</span> <span class="n">go</span> <span class="n">acc</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">acc</span>
</span><span class='line'>        <span class="n">go</span> <span class="n">acc</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">acc</span><span class="p">)</span> <span class="n">xs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- accumulator and tail recursion means foldl</span>
</span><span class='line'><span class="nf">reverse_3</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- the anonymous function in reverse_3 is actually flip (:)</span>
</span><span class='line'><span class="nf">reverse_4</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- foldl leaning so much to the left it comes back from the right:</span>
</span><span class='line'><span class="nf">reverse_5</span> <span class="n">ls</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="n">g</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">b</span><span class="kt">:</span><span class="n">xs</span><span class="p">))</span> <span class="n">id</span> <span class="n">ls</span> <span class="kt">[]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Colour pairs</h3>

<p>This is simple with list comprehensions. A way to ensure that only one of (black, blue) and (blue, black) is available is to filter the pairs so that the first element is smaller or equal than the second one.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Colour pairs  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">let</span> <span class="n">colours</span> <span class="ow">=</span><span class="p">[</span><span class="s">&quot;black&quot;</span><span class="p">,</span> <span class="s">&quot;white&quot;</span><span class="p">,</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="s">&quot;yellow&quot;</span><span class="p">,</span> <span class="s">&quot;red&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="ow">=</span> <span class="n">y</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>produces (reindented for readability):
<code>
[("black","black"),("black","white"),("black","blue"),
("black","yellow"),("black","red"),("white","white"),
("white","yellow"),("blue","white"),("blue","blue"),
("blue","yellow"),("blue","red"),("yellow","yellow"),
("red","white"),("red","yellow"),("red","red")]
</code></p>

<p>There are exactly 15 pairs, as expected.</p>

<h3>Multiplication table</h3>

<p>Nothing simpler:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Multiplication table  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">11</span><span class="p">],</span> <span class="n">y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">11</span><span class="p">]]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>produces (reindented for readability):
<code>
[(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1,10,10),(1,11,11),
(2,1,2),(2,2,4),(2,3,6),(2,4,8),(2,5,10),(2,6,12),(2,7,14),(2,8,16),(2,9,18),(2,10,20),(2,11,22),
(3,1,3),(3,2,6),(3,3,9),(3,4,12),(3,5,15),(3,6,18),(3,7,21),(3,8,24),(3,9,27),(3,10,30),(3,11,33),
(4,1,4),(4,2,8),(4,3,12),(4,4,16),(4,5,20),(4,6,24),(4,7,28),(4,8,32),(4,9,36),(4,10,40),(4,11,44),
(5,1,5),(5,2,10),(5,3,15),(5,4,20),(5,5,25),(5,6,30),(5,7,35),(5,8,40),(5,9,45),(5,10,50),(5,11,55),
(6,1,6),(6,2,12),(6,3,18),(6,4,24),(6,5,30),(6,6,36),(6,7,42),(6,8,48),(6,9,54),(6,10,60),(6,11,66),
(7,1,7),(7,2,14),(7,3,21),(7,4,28),(7,5,35),(7,6,42),(7,7,49),(7,8,56),(7,9,63),(7,10,70),(7,11,77),
(8,1,8),(8,2,16),(8,3,24),(8,4,32),(8,5,40),(8,6,48),(8,7,56),(8,8,64),(8,9,72),(8,10,80),(8,11,88),
(9,1,9),(9,2,18),(9,3,27),(9,4,36),(9,5,45),(9,6,54),(9,7,63),(9,8,72),(9,9,81),(9,10,90),(9,11,99),
(10,1,10),(10,2,20),(10,3,30),(10,4,40),(10,5,50),(10,6,60),(10,7,70),(10,8,80),(10,9,90),(10,10,100),(10,11,110),
(11,1,11),(11,2,22),(11,3,33),(11,4,44),(11,5,55),(11,6,66),(11,7,77),(11,8,88),(11,9,99),(11,10,110),(11,11,121)]
</code></p>

<h3>Map-colouring problem</h3>

<p>For this one, the code can be a bit simpler than Prolog's. The reason is that Prolog does not really have a different or not-equal operator: it has to use positive facts and cannot infer the relation is commutative. In Haskell, the list comprehension can have guards that are arbitrary boolean expressions, so we need to state only once that two states have different colours.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Map-colouring problem  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">let</span> <span class="n">colours</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="s">&quot;blue&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">[(</span><span class="n">alabama</span><span class="p">,</span> <span class="n">mississippi</span><span class="p">,</span> <span class="n">georgia</span><span class="p">,</span> <span class="n">tennessee</span><span class="p">,</span> <span class="n">florida</span><span class="p">)</span> <span class="o">|</span>
</span><span class='line'>  <span class="n">alabama</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span>
</span><span class='line'>  <span class="n">mississippi</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span>
</span><span class='line'>  <span class="n">georgia</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span>
</span><span class='line'>  <span class="n">tennessee</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span>
</span><span class='line'>  <span class="n">florida</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-</span> <span class="n">colours</span><span class="p">,</span>
</span><span class='line'>  <span class="n">mississippi</span> <span class="o">/=</span> <span class="n">tennessee</span><span class="p">,</span>
</span><span class='line'>  <span class="n">mississippi</span> <span class="o">/=</span> <span class="n">alabama</span><span class="p">,</span>
</span><span class='line'>  <span class="n">alabama</span> <span class="o">/=</span> <span class="n">tennessee</span><span class="p">,</span>
</span><span class='line'>  <span class="n">alabama</span> <span class="o">/=</span> <span class="n">georgia</span><span class="p">,</span>
</span><span class='line'>  <span class="n">alabama</span> <span class="o">/=</span> <span class="n">florida</span><span class="p">,</span>
</span><span class='line'>  <span class="n">georgia</span> <span class="o">/=</span> <span class="n">florida</span><span class="p">,</span>
</span><span class='line'>  <span class="n">georgia</span> <span class="o">/=</span> <span class="n">tennessee</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>produces (reindented for readability):
<code>
[("red","green","green","blue","blue"),
("red","blue","blue","green","green"),
("green","red","red","blue","blue"),
("green","blue","blue","red","red"),
("blue","red","red","green","green"),
("blue","green","green","red","red")]
</code></p>

<p>And that's all for Day 1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seven Languages in Seven Weeks Clojure Day 3]]></title>
    <link href="http://blog.wakatta.jp/blog/2011/11/13/seven-languages-in-seven-weeks-clojure-day-3/"/>
    <updated>2011-11-13T20:30:00+09:00</updated>
    <id>http://blog.wakatta.jp/blog/2011/11/13/seven-languages-in-seven-weeks-clojure-day-3</id>
    <content type="html"><![CDATA[<p>The final day with Clojure covers its support for concurrent programming. It has a bestiary of concepts that are somewhat similar yet distinct from other modern languages.</p>

<!--more-->


<p>First of all Clojure adopts the <a href="http://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a>, an approach mutable state and concurrency that is similar to databases. The idea is not really new, but it became more popular with Hashell's implementation.</p>

<p>There are also atoms, which are variables which guarantee atomic updates. The atomicity is a property of the atom, rather than of the functions that are used to update it, which is really nice.</p>

<p>Futures are also present. They represent values whose value is being computed in a dedicated thread. Trying to read from a <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/future"><code>future</code></a> could block if the value has not been computed yet (yes, Java has the same concept).</p>

<p>Finally, agents are ... somewhat perplexing. They look like agents in other languages (Io, Scala, Erlang, ...), except that they do not have any special behaviour attached. Instead, any function sent to them is queued and executed sequentially in a dedicated thread. At least, that's how I understand currently, but when I tried to use them for the Barber shop simulation, I ran into some problems, so there is more to this story.</p>

<h2>Exercises</h2>

<h3>Find the implemenation of a blocking queue</h3>

<p>The description of <a href="http://richhickey.github.com/clojure-contrib/seq-utils-api.html#clojure.contrib.seq-utils/fill-queue"><code>fill-queue</code></a> is a bit confusing, but it looks like a blocking lazy queue.</p>

<h3>Accounts simulation</h3>

<p>The code is very straightforward. An account is a <code>ref</code>, whose value is the balance. I add a validator function to each to ensure that the balance is not negative (<code>check-balance</code> is passed to <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/set-validator!"><code>set-validator!</code></a> in <code>make-account</code>).</p>

<p>The <code>credit</code> and <code>debit</code> functions just update the balance with the <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/alter"><code>alter</code></a> function. The transaction is not provided at this level just yet.</p>

<p>The <code>balance</code> function is just there for clarity.</p>

<p>The various <code>bank-</code> functions just operate on a vector of accounts, so they take the <code>bank</code> (a <code>vector</code>), and an <code>acc_num</code> (account number).</p>

<p>The <code>bank-transfer</code> is the only function using a transaction: it moves an amount between two accounts. To test the transaction failure mode, I credit the recipient account before I debit the other.</p>

<p>Finally, <code>bank-balances</code> prints the balance of all accounts.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Accounts simulation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">check-balance</span> <span class="p">[</span><span class="nv">b</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Check that the balance of account is not negative&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">&amp;lt</span><span class="c1">;= 0 b))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">make-account</span> <span class="p">[]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Create a new account&quot;</span>
</span><span class='line'><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">set-validator!</span> <span class="nv">r</span> <span class="nv">check-balance</span><span class="p">)</span>
</span><span class='line'>    <span class="nv">r</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">credit</span> <span class="p">[</span><span class="nv">account,</span> <span class="nv">amount</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Add amount to account&#39;s balance&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nb">alter </span><span class="nv">account</span> <span class="nv">+</span> <span class="nv">amount</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">debit</span> <span class="p">[</span><span class="nv">account,</span> <span class="nv">amount</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Debit amount from account&#39;s balance&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nb">alter </span><span class="nv">account</span> <span class="nv">-</span> <span class="nv">amount</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">balance</span> <span class="p">[</span><span class="nv">account</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Return balance of account&quot;</span>
</span><span class='line'><span class="nv">@account</span><span class="p">)</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">make-bank</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Create a bank of n accounts&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="nv">n</span> <span class="nv">make-account</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">bank-credit</span> <span class="p">[</span><span class="nv">bank,</span> <span class="nv">acc_num,</span> <span class="nv">amount</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Add amount to acc_num&#39;s balance&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">credit</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">bank</span> <span class="nv">acc_num</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">bank-debit</span> <span class="p">[</span><span class="nv">bank,</span> <span class="nv">acc_num,</span> <span class="nv">amount</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Debit amount from acc_num&#39;s balance&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">debit</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">bank</span> <span class="nv">acc_num</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">bank-balance</span> <span class="p">[</span><span class="nv">bank,</span> <span class="nv">acc_num</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Return the balance of acc_num&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">balance</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">bank</span> <span class="nv">acc_num</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">bank-transfer</span> <span class="p">[</span><span class="nv">bank,</span> <span class="nv">acc_num1,</span> <span class="nv">acc_num2,</span> <span class="nv">amount</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Transfer amount from acc_num1 to acc_num2 in bank&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nb">dosync </span>
</span><span class='line'>    <span class="p">(</span><span class="nf">bank-credit</span> <span class="nv">bank</span> <span class="nv">acc_num2</span> <span class="nv">amount</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">bank-debit</span> <span class="nv">bank</span> <span class="nv">acc_num1</span> <span class="nv">amount</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">bank-balances</span> <span class="p">[</span><span class="nv">bank</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;Show the balance of all accounts&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">count </span><span class="nv">bank</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Account &quot;</span> <span class="nv">i</span> <span class="s">&quot;: &quot;</span> <span class="p">(</span><span class="nf">bank-balance</span> <span class="nv">bank</span> <span class="nv">i</span><span class="p">)))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The test code:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Test code  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; create the bank</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">bank</span> <span class="p">(</span><span class="nf">make-bank</span> <span class="mi">3</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; put some money in</span>
</span><span class='line'><span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">bank-credit</span> <span class="nv">bank</span> <span class="mi">0</span> <span class="mi">100</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; show the balances</span>
</span><span class='line'><span class="p">(</span><span class="nf">bank-balances</span> <span class="nv">bank</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; a first transfer</span>
</span><span class='line'><span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">bank-transfer</span> <span class="nv">bank</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">75</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; show the balances</span>
</span><span class='line'><span class="p">(</span><span class="nf">bank-balances</span> <span class="nv">bank</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; not enough fund, so it will fail</span>
</span><span class='line'><span class="p">(</span><span class="nb">dosync </span><span class="p">(</span><span class="nf">bank-transfer</span> <span class="nv">bank</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">75</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">;; and indeed, the balances have not changed</span>
</span><span class='line'><span class="p">(</span><span class="nf">bank-balances</span> <span class="nv">bank</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When input into the repl, the test code gives the following output:</p>

<p>```
user=> (def bank (make-bank 3))</p>

<h1>'user/bank</h1>

<p>user=> (dosync (bank-credit bank 0 100))
100
user=> (bank-balances bank)
Account 0: 100
Account 1: 0
Account 2: 0
nil
user=> (dosync (bank-transfer bank 0 1 75))
25
user=> (bank-balances bank)
Account 0: 25
Account 1: 75
Account 2: 0
nil
user=> (dosync (bank-transfer bank 0 2 75))
java.lang.IllegalStateException: Invalid reference state (NO_SOURCE_FILE:0)
user=> (bank-balances bank)
Account 0: 25
Account 1: 75
Account 2: 0
nil
```</p>

<p>So the balance is protected from being negative, and the transaction is rolled back. Despite the fact that the amount was supposed to be credited to account number 2 first, the balance of that account has not changed as the transaction failed.</p>

<h3>Barber shop simulation</h3>

<p>This problem was mostly a matter of figuring out the right model. The concept of agent seems to have some hidden complexity (or lock) which prevented my initial solution from working.</p>

<p>The idea is that the <code>barber</code> is an agent; it is updated by a function representing getting an haircut (<code>get-haircut</code>). The value of the agent is the number of client served.</p>

<p>The <code>waiting-room</code> is an atom. It's value is the number of free chairs.</p>

<p>The <code>get-haircut</code> function is sent to the <code>barber</code>. When it starts, it frees (increase) the <code>waiting-room</code> count of free chairs. Then it waits for 20 milliseconds, and finally updates the <code>barber</code> count of clients.</p>

<p>Finally, the <code>try-to-sit</code> function checks the number of free chairs: if none, the customer just leaves. Otherwise, the customer sits in a chair (signaling it's intent to get a haircut by sending <code>get-haircut</code> to the <code>barber</code>), and the count of free chairs is decreased. I tried to print a statement when a customer leaves because there is no chair, but there were too many such messages so I commented it out.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Barber problem, part 1  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">barber</span> <span class="p">(</span><span class="nb">agent </span><span class="mi">0</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">def </span><span class="nv">waiting-room</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">3</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">get-haircut</span> <span class="p">[</span><span class="nv">count</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nf">swap!</span> <span class="nv">waiting-room</span> <span class="nv">inc</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Start haircut&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">20</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">inc </span><span class="nv">count</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">try-to-sit</span> <span class="p">[</span><span class="nv">count</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">== </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">do</span>
</span><span class='line'>        <span class="c1">;;(println &quot;No free chairs. The customer leaves&quot;)</span>
</span><span class='line'>        <span class="nv">count</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">do</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Sit in waiting room&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">send </span><span class="nv">barber</span> <span class="nv">get-haircut</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">dec </span><span class="nv">count</span><span class="p">))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When a new customer walks in, it will try to sit in a free chair. This is done in the <code>new-customer</code> function.</p>

<p>The <code>shop-loop</code> is a tail recursive loop that initiates a <code>new-customer</code> at random intervals. It runs until after at least <code>max</code> milliseconds.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Barber problem, part 2  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">new-customer</span> <span class="p">[]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">waiting-room</span> <span class="nv">try-to-sit</span><span class="p">))</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">shop-loop</span> <span class="p">[</span><span class="nv">max</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">orig</span> <span class="p">(</span><span class="nf">System/currentTimeMillis</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">loop </span><span class="p">[]</span>
</span><span class='line'>        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">&amp;lt</span><span class="c1">; (- (System/currentTimeMillis) orig) max)</span>
</span><span class='line'>            <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">next</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="p">(</span><span class="nb">rand </span><span class="mi">20</span><span class="p">))]</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="nv">next</span><span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">new-customer</span><span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">recur</span><span class="p">))</span>
</span><span class='line'>            <span class="nv">max</span><span class="p">))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally we get to the main function. First <code>init</code> is defined to help reset the values of atoms and agents. Then <code>start</code> will indeed reset all values, then run <code>shop-loop</code> in a <code>future</code>, wait the required amount of time, and finally get the current value of <code>barber</code> (which might not have fully finished). My first version tried to run <code>shop-loop</code> on a dedicated agent, but that was for some reason blocking on the <code>barber</code> agent, so I used a <code>future</code> instead.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Barber problem, part 3  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">init</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">v</span><span class="p">]</span> <span class="nv">v</span><span class="p">)</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="k">defn </span><span class="nv">start</span> <span class="p">[</span><span class="nv">max</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;starting&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">send </span><span class="nv">barber</span> <span class="nv">init</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nf">swap!</span> <span class="nv">waiting-room</span> <span class="nv">init</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nf">shop-loop</span> <span class="nv">max</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="nv">max</span><span class="p">)</span>
</span><span class='line'><span class="nv">@barber</span><span class="p">)</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>With this implementation, the barber performed 458 hair cuts (500 was the theoretical maximum).</p>

<h2>Wrapping up Clojure</h2>

<p>There is much more to Clojure that what has been covered so far. The object model is far more flexible than Java's. Metadata can be added to various entities, which I understand could be used to improve interactive usage (documentation strings are already a kinf of metadata).</p>

<p>I always found Lisp languages to be very elegant and expressive; Clojure definitively is a Lisp, and I really wanted to like the language. Yet for some reason I found it somewhat disappointing. Perhaps it is the limitations the designers put (for good reason) in the language. Perhaps it is the fact that the language runs on the JVM, an environment that I instinctively link to all things corporate, safe and boring, so I don't really believe it could be exciting.</p>

<p>I'm not really sure, perhaps it is just that I'm feeling tired and I have a cold, and Clojure really is awesome. So I'll have another look at that language, and I hope I can give it the attention it seems to deserve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seven Languages in Seven Weeks Clojure Day 2]]></title>
    <link href="http://blog.wakatta.jp/blog/2011/11/12/seven-languages-in-seven-weeks-clojure-day-2/"/>
    <updated>2011-11-12T19:25:00+09:00</updated>
    <id>http://blog.wakatta.jp/blog/2011/11/12/seven-languages-in-seven-weeks-clojure-day-2</id>
    <content type="html"><![CDATA[<p>Today Clojure's coverage is getting beefier with tail recursion (soso), lazy sequences and ... macros!</p>

<!--more-->


<p>The support for tail recursion is disappointing. But given that the JVM implementers never actually understood the value of tail recursion (or perhaps they overestimated its cost), it would have been surprising if a language running on top of the JVM had a solution. Scala is similarly limited.</p>

<p>Lazy sequences are cool, but not spectacularly so. It is a more restricted concept than laziness in Haskell. Still, lazy lists form a large part of my use of Haskell's laziness (perhaps the only part I can use), so I do not expect to feel limited in any way with Clojure.</p>

<p>Finally, macros. Writing macros separates men from boys. Writing macros that write macros separates gods from men. Macros are good. Abuse of macros can cause headaches, but the good kind (it's just your brain swelling).</p>

<h2>Exercises</h2>

<h3>Implementation of common macros in Clojure</h3>

<p>That one is very easy. The web site has a dedicated <a href="http://clojure.org/macros">page</a> with the common macros. The source code is available for each. <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defmacro"><code>defmacro</code></a> is actually a macro, and its source code is, well, let's just say I'm happy someone else wrote it. And yes, it is a macro that writes macros.</p>

<p>To expand the code of macros, I wrote this small function to recursively expand macro definitions:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>rec-expand function  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">rec-expand</span> <span class="p">[</span><span class="nv">lst</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span>      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq? </span><span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="nv">rec-expand</span> <span class="p">(</span><span class="nb">macroexpand </span><span class="nv">lst</span><span class="p">))</span> <span class="nv">lst</span><span class="p">))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Without it, it is difficult to see deeply into the code:
```
user=> (macroexpand '(defn collection-type</p>

<pre><code>         "Return either :list, :vector or :map, depending of the type of col."                      
         [col]                                                                                      
         (cond (list? col) :list
               (map? col) :map
               (vector? col) :vector)))
</code></pre>

<p>(def collection-type (.withMeta (clojure.core/fn collection-type ([col] (cond (list? col) :list (map? col) :map (vector? col) :vector))) (.meta (var collection-type))))
```</p>

<p><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/macroexpand"><code>macroexpand</code></a> did not expand the <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/cond"><code>cond</code></a> macros.</p>

<p>With <code>rec-expand</code>:
```
user=> (rec-expand '(defn collection-type</p>

<pre><code>         "Return either :list, :vector or :map, depending of the type of col."                      
         [col]                                                                                      
         (cond (list? col) :list
               (map? col) :map
               (vector? col) :vector))) 
</code></pre>

<p>(def collection-type (. (fn* collection-type ([col] (if (list? col) :list (if (map? col) :map (if (vector? col) :vector ()))))) withMeta (. (var collection-type) meta)))
```</p>

<h3>Implementation of a lazy sequence</h3>

<p>For this exercise, I use <a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/lazy-seq"><code>lazy-seq</code></a>, which evaluates its body on demand (and remembers the value).</p>

<p>One first example is a simple reimplementation of <code>(iterate inc n)</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>upfrom  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">upfrom</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="s">&quot;[n, n+1, n+2, ....&quot;</span>
</span><span class='line'><span class="p">(</span><span class="nf">lazy-seq</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">n</span> <span class="p">(</span><span class="nf">upfrom</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">n</span><span class="p">)))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing it:
<code>
user=&gt; (take 10 (upfrom 0))
(0 1 2 3 4 5 6 7 8 9)
</code></p>

<p>A bit more interesting, perhaps, is a Fibonacci sequence not using <code>map</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Fibonacci sequence  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defn </span><span class="nv">fibs</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Fibonacci sequence starting with a, b, ...&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">lazy-seq</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">a</span> <span class="p">(</span><span class="nf">fibs</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">fib</span> <span class="p">(</span><span class="nf">fibs</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Computing the 20 first Fibonacci numbers:
<code>
user=&gt; (take 20 fib)
(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765)
</code></p>

<h3>Unless with else condition</h3>

<p>For this exercise, I use two features that were not covered in the book</p>

<ul>
<li>variable lists of arguments support</li>
<li>backquote notation</li>
</ul>


<p>Clojure support for variable lists of arguments is nice: there can be a different body for each list, and the last one can a placeholder variable for "all the remaining arguments". The concept of arguments (and variable lists) applies to everything that takes arguments: functions, macros, ... Here I use it to differentiate between basic <code>(unless test body)</code> and <code>(unless test body else)</code>.</p>

<p>Backquote notation is what makes macro useable. Rather than using <code>list</code> to build the form, I use the backquote. Then expressions prefixed with tilde are replaced by their value. Lisps had an identical concept (but comma was used instead of tilde).</p>

<p>This makes macros shorter and easier to read.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>extended unless  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">defmacro </span><span class="nv">unless</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">test</span> <span class="nv">body</span><span class="p">]</span> <span class="nv">&lt;code&gt;</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">~test</span><span class="p">)</span> <span class="nv">~body</span><span class="p">))</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">test</span> <span class="nv">body</span> <span class="nv">alt</span><span class="p">]</span><span class="nv">&lt;/code&gt;</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">~test</span><span class="p">)</span> <span class="nv">~body</span> <span class="nv">~alt</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing it:
<code>
user=&gt; (unless false (println "Danger!"))
Danger!
nil
user=&gt; (unless true (println "Danger!") (println "No danger..."))
No danger...
nil
</code></p>

<h3>Using defrecord and defprotocol</h3>

<p>Ok, I'm not very inspired by this exercise. I was thinking of doing the classic shape class hierarchy, but finally settled for an employee protocol:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Employee protocol  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defprotocol</span> <span class="nv">Employee</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">work</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">h</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">get-raise</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">a</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The first implementation is a manager, which is modeled according to things I've heard about other companies, not mine, where managers are hard-working and have to be pulled from their desk to be fed:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Manager implementation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrecord</span> <span class="nv">Manager</span> <span class="p">[</span><span class="nv">hobby</span><span class="p">]</span>       <span class="nv">&lt;br/&gt;</span>
</span><span class='line'>  <span class="nv">Employee</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">work</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">h</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Working &quot;</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">h</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot; hours then &quot;</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">h</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot; hours of &quot;</span> <span class="nv">hobby</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>  <span class="p">(</span><span class="nf">get-raise</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">a</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;You are too modest. You deserve &quot;</span> <span class="p">(</span><span class="nb">* </span><span class="mf">1.1</span> <span class="nv">a</span><span class="p">)))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing the manager:
```
user=> (def m (Manager. "golf"))</p>

<h1>'user/m</h1>

<p>user=> (work m 8)
Working 4 hours then 4 hours of golf
nil
user=> (get-raise m 1000)
You are too modest. You deserve 1100.0
nil
```</p>

<p>Of course we need people to actually do something:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Worker implemenation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrecord</span> <span class="nv">Worker</span> <span class="p">[]</span>       <span class="nv">&lt;br/&gt;</span>
</span><span class='line'>  <span class="nv">Employee</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">work</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">h</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;Working &quot;</span> <span class="nv">h</span> <span class="s">&quot; hours then &quot;</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">h</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot; hours overtime&quot;</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>  <span class="p">(</span><span class="nf">get-raise</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">a</span><span class="p">]</span><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;pre&gt;&lt;code&gt;</span><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">&quot;There is an economic crisis. Be happy with &quot;</span> <span class="p">(</span><span class="nb">* </span><span class="mf">0.1</span> <span class="nv">a</span><span class="p">)))))</span>
</span><span class='line'><span class="nv">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Testing the worker:
```
user=> (def w (Worker.))</p>

<h1>'user/w</h1>

<p>user=> (work w 8)
Working 8 hours then 4 hours overtime
nil
user=> (get-raise w 100)
There is an economic crisis. Be happy with 10.0
nil
```</p>

<p>Ok, nothing fancy. But looking at the doc I see it is possible to extend basic Java classes, so I think there's far more depth to this construct. Otherwise, there's always <code>defmacro</code> to play with.</p>

<p>And this completes Day 2.</p>
]]></content>
  </entry>
  
</feed>
